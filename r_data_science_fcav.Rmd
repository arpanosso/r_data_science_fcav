--- 
title: "Análise de Dados de Ciência do Solo no R"
author: "Alan R. Panosso <alan.panosso@unesp.br> & Gener T. Pereira <gener.t.pereira@unesp.br>"
date: "01 a 12 de Fevereiro de 2021"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "Disciplina ministrada no primeiro semestre de 2021 no curso de Pós-graduação em Agronomia (Ciência do Solo) da Faculdade de Ciências Agrárias e Veterinarias (FCAV) da UNESP de Jaboticabal."
---

# Bem-vindos!! {-}

Placeholder



<!--chapter:end:index.Rmd-->

# Ambientação

## Instalando o R

Faça o download do R do site oficial The R Project for Statistical Computing <https://www.r-project.org/>

Acesso rápido: [Download](<https://cran-r.c3sl.ufpr.br/bin/windows/base/R-4.0.3-win.exe>)


Salve o arquivo de instalação em um diretório de seu computador e em seguida execute-o. 

O processo é simples e intuitivo.

## Instalando o RStudio

É um ambiente de desenvolvimento integrado (IDE) para o R, disponível em <https://rstudio.com/products/rstudio/download/>

Escolha o instalador de acordo com o seu sistema operacional. **Windows** no nosso caso.

Novamente, salve o arquivo de instalação em um diretório de seu computador e em seguida execute-o.

Após a instalação procure o ícone do R criado pelo instalador e clique nele.

Um breve tutorial para instalação do R e do RStudio pode ser encontrado no vídeo abaixo.

<iframe width="560" height="315" src="https://www.youtube.com/embed/AqTzQzuQUPw" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<!--chapter:end:01-ambi.Rmd-->


# Pacotes no R 

Placeholder


## Pacotes básicos
## Instalando pacotes

<!--chapter:end:02-pacotes.Rmd-->


# Lógica de Programação 

Placeholder


## Introdução
## Conceitos básicos

<!--chapter:end:03-Logica.Rmd-->


# Introdução à Ciência dos Dados

Placeholder


## Importação
## Organização
## Transformação dos dados
## Visualização
## Modelação
## Comunicação
## Programação

<!--chapter:end:04-intro.Rmd-->


# Tópicos iniciais  

Placeholder


## Identificadores
## Palavras Reservadas
## Regras para os nomes de Identificadores  
## Tipos de dados
## Atribuição
## Operadores
## Operação aritmética
## Funções matemáticas e trigonométricas 
## Operações Relacionais
## Operações Lógicas
## Exercícios

<!--chapter:end:05-TopInici.Rmd-->


# Algoritmos

Placeholder


## Estruturas de Controle
### Sequêncial 
### Seleção
### Repetição 
## Exercícios  

<!--chapter:end:06-Algoritm.Rmd-->


# Estrutura de dados

Placeholder


## Atomic vector
## Factor
## Matrizes e Arrays
## Listas
## Data frames

<!--chapter:end:07-EstruDados.Rmd-->


# Visualização de dados com o ggplot2

Placeholder


## Criando um gráfico
## Controlando geometrias
## Definindo temas
## Controlando elementos do tema
## Mapeamento estéticos
## Facetas
## Objetos geométricos
### Gráfico de Colunas
### Gráfico de Barras
### Smoothers
### Boxplot
### Histograma

<!--chapter:end:08-VisuaDados.Rmd-->


# Manipulação de dados com o dplyr

Placeholder


## Principais funções (verbos) do `dplyr`.  
## Regras para manipulação:  
## filter()
### Valores Faltantes
### Strings e Regex
## arrange()
## select()
## mutate()
## Resumos Agrupados com summarize()
### Valores faltantes
### Counts

<!--chapter:end:09-TransfDados.Rmd-->

# Análise Exploratória de Dados (AED)

A AED não é um processo com um conjunto de regras rígidas. Mais do que qualquer coisa, é uma estado de espírito. Durante as fazes iniciais de AED, devemos ser livres para investigar cada ideia que ocorra.

À medida que a exploração segue, nos direcionamos para algumas áreas particularmente produtivas que, por fim, deverão ser escritas e comunicadas.

É considera uma fase importante de qualquer análise, pois mesmo se as perguntas já foram formuladas, sempre será necessário pesquisar a qualidade dos dados que temos em mãos.

Assim, a limpeza de dados é apenas uma aplicação da AED, na qual serão necessárias as ferramentas de visualização, transformação e modelagem.

A AED é o cálculo das estatísticas tradicionais, alguns exemplos:

  * Univariadas: média, mediana, desvio padrão, 1º e 3º quartis, mínimo, máximo, coeficientes die variação, de assimetria e curtosis, histogramas, boxplot, gráficos de regressão, gráficos de dispersão, entre outros.

  * Bivariadas – análise de `cluster`, análise de componentes principais, análise de fatores e análise de variância.
  
  
  
  
  
  
  
  
### Algumas funções de resumo

Aliadas à média e à contagem, várias outras funções podem ser utilizadas em R.

*Medidas de localização*

A função `median()` retorna a mediana do conjunto de dados, ou seja,  um valor onde $50\%$ de $x$ está acima e $50\%$ está abaixo dela. Já a média `mean()` é a soma dividida pelo comprimento. Assim, a mediana não é influenciada por valores extremos, diferente da média. Compare a diferença entre média e mediana para as variáveis `ARGILA` e em seguida `P`.


```{r,message=FALSE}
# Para Argila
geomorfologia %>% 
  group_by(SUP) %>% 
  summarize(Media = mean(ARGILA, na.rm = TRUE),
            Mediana = median(ARGILA, na.rm = TRUE))

# Para P
geomorfologia %>% 
  group_by(SUP) %>% 
  summarize(Media = mean(P, na.rm = TRUE),
            Mediana = median(P, na.rm = TRUE))
```


*Medidas de dispersão*

O desvio padrão `sd()` é a medida de dispersão padrão. Outras medidas podem ser utilizadas, como a variação interquartil `IQR()` e o desvio absoluto mediano `mad()` são equivalentes obustos que podem ser mais úteis se você tiver outliers.
```{r,message=FALSE}
# Para P
geomorfologia %>% 
  group_by(SUP) %>% 
  summarize(Media = mean(P, na.rm = TRUE),
            Mediana = median(P, na.rm = TRUE),
            DP=sd(P, na.rm = TRUE),
            IQR=IQR(P, na.rm = TRUE),
            DA_mediano = mad(P, na.rm = TRUE))
```

*Medidas de classificação*

São os valores mínimo/máximo e os quantis. Quantis são generalizações da mediana. Por exemplo, `quantile(x, 0.25)` encontrará o valor de `x` que é maior que $25\%$ dos valores e menor do que os $75\%$ restantes. Já `quantile(x, 0.75)` encontrará o valor de `x` que é maior que $75\%$ dos valores e menor do que os $25\%$ restantes.

```{r,message=FALSE}
# Para P
geomorfologia %>% 
  group_by(SUP) %>% 
  summarize(Media = mean(P, na.rm = TRUE),
            Mediana = median(P, na.rm = TRUE),
            DP=sd(P, na.rm = TRUE),
            IQR=IQR(P, na.rm = TRUE),
            DA_mediano = mad(P, na.rm = TRUE),
            Mínimo = min(P, na.rm = TRUE),
            Q1 = quantile(P, 0.25, na.rm = TRUE),
            Q3 = quantile(P, 0.75, na.rm = TRUE),
            Máximo = max(P, na.rm = TRUE)) 
```

*Contagens*

Vamos agora contar o número de observações e o número de valores não faltantes, utilizando as funções `n()` e `sum(!is.na(x))`:

```{r,message=FALSE}
# Para P
geomorfologia %>% 
  group_by(SUP) %>% 
  summarize(Media = mean(P, na.rm = TRUE),
            Mediana = median(P, na.rm = TRUE),
            DP=sd(P, na.rm = TRUE),
            IQR=IQR(P, na.rm = TRUE),
            DA_mediano = mad(P, na.rm = TRUE),
            Mínimo = min(P, na.rm = TRUE),
            Q1 = quantile(P, 0.25, na.rm = TRUE),
            Q3 = quantile(P, 0.75, na.rm = TRUE),
            Máximo = max(P, na.rm = TRUE),
            N=n(),
            N_na = sum(!is.na(P))) 
```

Contagens e proporções de valores lógicos `sum(x > 10)`, `mean(y == 0)`. Quando usado com funções numéricas, `TRUE` é convertido em $1$, e `FALSE` em $0$. ISso  torna `sum()` e `mean()` muito úteis: `sum()` retorna o número de `TRUE` em x e `mean(x)` retorna a proporção. 

Por exemplo, em cada supefície geomórfica, vamos calcular o número e a proporção de valores de `P` inferiores a 10.

```{r,message=FALSE}
# Para P
geomorfologia %>% 
  group_by(SUP) %>% 
  summarize(Media = mean(P, na.rm = TRUE),
            Mediana = median(P, na.rm = TRUE),
            DP=sd(P, na.rm = TRUE),
            IQR=IQR(P, na.rm = TRUE),
            DA_mediano = mad(P, na.rm = TRUE),
            Mínimo = min(P, na.rm = TRUE),
            Q1 = quantile(P, 0.25, na.rm = TRUE),
            Q3 = quantile(P, 0.75, na.rm = TRUE),
            Máximo = max(P, na.rm = TRUE),
            N=n(),
            N_na = sum(!is.na(P)),
            n10=sum(P<10),
            n10p=mean(P<10)) 
```

*Medidas da Forma da Distribuição*

As medidas da forma da distribuição são os coeficientes de assimetria e curtosis.

**Assimetria** - é uma medida da simetria da distribuição de frequência. Ela mostra se os desvios da média são maiores para um lado da distribuição do que para o outro. Usualmente, a estimativa do Coeficiente de Assimetria pode ser calculada pela fórmula:

$$
G_1 = \frac{n}{(n-1)(n-2)} \cdot \frac{\sum_{i=1}^n(x_i - \bar{x})^3}{s^3}
$$

Vamos utilizar a função `skewness()` do pacote `agricolae` para calcular o coeficente de assimetria.

```{r,message=FALSE}
# Para P
geomorfologia %>% 
  group_by(SUP) %>% 
  summarize(Media = mean(P, na.rm = TRUE),
            Mediana = median(P, na.rm = TRUE),
            DP=sd(P, na.rm = TRUE),
            IQR=IQR(P, na.rm = TRUE),
            DA_mediano = mad(P, na.rm = TRUE),
            Mínimo = min(P, na.rm = TRUE),
            Q1 = quantile(P, 0.25, na.rm = TRUE),
            Q3 = quantile(P, 0.75, na.rm = TRUE),
            Máximo = max(P, na.rm = TRUE),
            N=n(),
            N_na = sum(!is.na(P)),
            n10=sum(P<10),
            n10p=mean(P<10),
            G1 = agricolae::skewness(P)) 
```

Se as observações apresentam distribuição simétrica, $G_1= 0$, ou próximas a $0$.

O coeficiente de assimetria é o indicativo mais comum de Normalidade. Em dados assimétricos, existem dúvidas sobre qual medida de tendência central devemos utilizar para resumir os dados. Nesses casos, comparações entre médias de diferentes conjuntos de observações são não confiáveis, uma vez que a variância pode diferir substancialmente de um conjunto de observações para outro.

```{r}
geomorfologia %>% 
  ggplot(aes(x=P,y=..density..)) + 
  geom_histogram(bins=30, color="black", fill="white")+
  facet_wrap(~SUP, scales = "free")+
  geom_density(alpha=0.1,fill="red")
```


**Curtose** - Indica o grau de achatamento de uma distribuição, é a medida do peso das  caudas da distribuição. Se as observações seguem uma distribuição normal, então o coeficiente de curtose é zero, e sua estimativa é dado por: 

$$
G_2 = \frac{\frac{\sum{i=1}^n(x-\bar{x})^4}{s^4}}{(n-3)(n-2)(n-1)}-3 \cdot \frac{(n-1)^2}{(n-2)(n-3)}
$$

Vamos utilizar a função `kurtosis()` do pacote `agricolae` para calcular o coeficente de assimetria.

```{r,message=FALSE}
# Para P
geomorfologia %>% 
  group_by(SUP) %>% 
  summarize(Media = mean(P, na.rm = TRUE),
            Mediana = median(P, na.rm = TRUE),
            DP=sd(P, na.rm = TRUE),
            IQR=IQR(P, na.rm = TRUE),
            DA_mediano = mad(P, na.rm = TRUE),
            Mínimo = min(P, na.rm = TRUE),
            Q1 = quantile(P, 0.25, na.rm = TRUE),
            Q3 = quantile(P, 0.75, na.rm = TRUE),
            Máximo = max(P, na.rm = TRUE),
            N=n(),
            N_na = sum(!is.na(P)),
            n10=sum(P<10),
            n10p=mean(P<10),
            G1 = agricolae::skewness(P),
            G2 = agricolae::kurtosis(P)) 
```
  
  
  
  
  
  
  
  
  
**Importação dos dados** 

Vamos realizar a importação, via web, do banco de dados [transectos.txt](https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/transectos.txt).

```{r}
library(tidyverse)
URL <- "https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/transectos.txt"
transectos<-read.table(URL,header = TRUE)
glimpse(transectos)
```

As colunas `X` e `Y` denotam as coordenadas de cada ponto amostral dentro do gradeado experimental. Vamos vizualizar o gradeado.

```{r}
transectos %>% 
  ggplot(aes(x=X, y=Y))+
  geom_point(size=2)+
  theme_minimal()
```

## Descrevendo os dados amostrais

Visualizar a distribuição de uma variável dependerá se a variável é **categórica** ou **contínua**. Uma variável **categórica** só pode assumir um pequeno conjunto de valores. Em R essas variáveis são geralmente salvas na forma de *fatores* ou *strings*.

```{r}
glimpse(transectos)
```

Agora, vamos criar um gráfico de barras para visualizar a variável categórica `Transecto`, ou seja, o número de observações que ocorre em cada transecto.

```{r}
transectos %>% 
  ggplot(aes(x = Transecto))+
  geom_bar(fill="lightblue", color="black")
```

Muitas vezes precisamos modificar a escala dos eixos para melhorar e focar nossa visualização nas diferenças, então, vamos utilizar a função `coord_cartesian()`:

```{r}
transectos %>% 
  ggplot(aes(x = Transecto))+
  geom_bar(fill="lightblue",color="black") +
  coord_cartesian(ylim= c(55,63))
```

**OBS**: A função `coord_cartesian()` também tem um argumento `xlim` para quando precisamos focar no eixo x.

Agora vamos visualizar a tabela.
```{r}
transectos %>% 
  count(Transecto)
```

Uma variável **contínua** pode assumir qualquer valor de um conjunto infinito de valores ordenados. Para examinarmos a distribuição de uma variável contínua, vamos utilizar o histograma.

**Argila**
```{r}
transectos %>% 
  ggplot(aes(x=Argila)) +
  geom_histogram(bins=20, color="black",fill="lightgray")
```

Podemos sobrepor vários histogramas no mesmo gráfico, para isso, utilize `geom_freqpoly()`. Observe que vamos criar os polígonos a partir da densidade e frequência $d_i$:

$$
d_i = \frac{f_i}{\Delta_i}
$$

onde,

$f_i$ é a frequência relativa dada pela contagem de cada classe individual $i$, dividida pelo número total de observações ($n$).

$$
f_i = \frac{count_i}{n}
$$

$\Delta_i$ é o intervalo de cada classe específica $i$.

```{r}
transectos %>% 
  ggplot(aes(x=Argila, color=Transecto, y= ..density..)) + 
  geom_freqpoly()
```

O histograma fornece informação sobre:  
  * Tipo de distribuição;  
  * Unimodal ou multimodal;  
  * Presença de valores extremos ("outliers");  
  * Variabilidade.
  

Outra possibilidade é o uso do *Boxplot*, para isso vamos verificar a variável `Silte`:


```{r}
transectos %>% 
  ggplot(aes(y=Silte)) + 
  geom_boxplot()
```

Vamos modificar o gráfico, alterando as cores e a escala do eixo X para modificar a caixa.

```{r}
transectos %>% 
  ggplot(aes(y=Silte)) + 
  geom_boxplot(color="black",fill="lightblue")+
  coord_cartesian(xlim=c(-1,1))+
  theme_minimal()
```

Podemos construir o boxplot segmentado por transecto.

```{r}
transectos %>% 
  ggplot(aes(y=Silte, x=Transecto, fill=Transecto)) + 
  geom_boxplot()
```


Para facilitar a visualização da tendência, podemos reordenar `nome_transecto` com base no valor médio do teor de silte do solo.

```{r}
transectos %>% 
  ggplot(aes(y=Silte, x=reorder(Transecto,Silte,mean), fill=Transecto)) + 
  geom_boxplot()
```

Se temos nomes longos, podemos rotacionar o gráfico 90º com `coord_flip()`.

```{r}
transectos %>% 
  ggplot(aes(y=Silte, 
             x=reorder(Transecto, Silte, mean), 
             fill=Transecto)) + 
  geom_boxplot()+
  coord_flip()
```

**Violin plot**

O violin plot é um método de visualizar dados numéricos. É semelhante a um boxplot, com a adição de um gráfico de densidade girado em cada lado. 

São semelhantes aos boxplot, exceto que também mostram a densidade de probabilidade dos dados em valores diferentes. Normalmente, um gráfico de violino incluirá todos valores que estão no boxplot: um marcador para a mediana dos dados, uma caixa ou marcador indicando o intervalo interquartil e, possivelmente, todos os pontos de amostra, se o número de amostras não for muito alto. A diferença é particularmente útil quando a distribuição de dados é multimodal (mais de um pico). Neste caso, um gráfico de violino mostra a presença de diferentes picos, sua posição e amplitude relativa.

```{r}
transectos %>% 
  ggplot(aes(y=Silte, 
             x=reorder(Transecto, Silte, mean), 
             fill=Transecto)) + 
  geom_violin(trim = FALSE)+
  stat_summary(fun = median, geom = "point", shape=21, size=3, color="black", fill="gray") +
  theme(legend.position="none")
```

A densidade de distribuição dos pontos pode ser visualizada com a função `geom_dotplot()`.

```{r,message=FALSE,error=FALSE}
transectos %>% 
  ggplot(aes(x=Transecto,y=Silte))+
  geom_violin(trim = FALSE) +
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1)
```

Muitas vezes, podemos mesclar o **boxplot** com o **violin plot**. A largura das caixas pode ser controlada com o argumento `width`.

```{r}
transectos %>% 
  ggplot(aes(y=Silte, 
             x=reorder(Transecto, Silte, mean), 
             fill=Transecto)) + 
  geom_violin(trim=FALSE, fill="lightgray")+
  geom_boxplot(width=0.1)+
  theme_classic()
```

**Função Densidade Acumulada Empírica**

A função de distribuição cumulativa empírica (*empirical cumulative distribution function * - ECDF) fornece uma visualização alternativa da distribuição. Em comparação com outras visualizações que dependem da densidade (como geom_histogram), o ECDF não requer nenhum parâmetro de ajuste e lida com variáveis contínuas e categóricas.

A desvantagem é que requer mais treinamento para interpretar com precisão e as tarefas visuais subjacentes são um pouco mais desafiadoras.

A função de distribuição acumulada descreve como probabilidades são associadas aos valores ou aos intervalos de valores de uma variável aleatória. Ela representa a probabilidade de uma variável aleatória ser menor ou igual a um valor real $x$.  

$$
F(x) = P(X \le x)
$$
Em R pode ser desenhanda com `stat_ecdf()` 

```{r}
transectos %>% 
  ggplot(aes(x=Silte)) +
  stat_ecdf(geom = "line")
```
A representação pode ser segmentada por cada categoria da variável categórica.

```{r}
transectos %>% 
  ggplot(aes(x=Silte, color= Transecto)) +
  stat_ecdf(geom = "line")
```

As variáveis `Argila`, `Silte` e `Areia` são expressas em porcentagem, assim, poderíamos colocá-las em um mesmo gráfico e adicionar uma legenda para identificar cada uma delas. 

Podemos realizar essa tarefa utilizando a função `gather()` do pacote `tidyr`.

Literalmente a função **empilha** o banco de dados. Nesse exemplo, vamos criar uma nova variável denominada `granulometria` que deverá receber repedidamente os nomes das colunas (`Areia`, `Silte` e `Argila`), preservando o valor numérico dessas variáveis que serão empilhados na nova variável `valor`. Observe a figura:

```{r echo=FALSE, fig.cap="Exemplo simples do comportamento da função `gather()`.",fig.align='center',out.width = "800px"}
knitr::include_graphics("img/gather.png")
```
A função tem como argumentos os nomes das duas novas colunas `granulometria` e `valor`, sendo o  terceiro argumento da função as posições das colunas que deverão ser empilhadas (`5:7`).

```{r}
transectos %>% 
  gather(granulometria, valor, 5:7) %>% 
  View()
```

Podemos completar o código acima pedindo a partir do `ggplot()` o boxplot por granulometria em cada posição de X, por exemplo:


```{r}
transectos %>% 
  gather(granulometria, valor, 5:7) %>% 
  ggplot(aes(y=valor, x=as.factor(X),fill=granulometria)) +
  geom_boxplot()+
  theme(axis.text.x=element_text(angle=90, hjus=1,size = rel(0.8)))
```

Ou, podemos pedir para cada transecto, `Y` no caso.

```{r}
transectos %>% 
  gather(granulometria, valor, 5:7) %>% 
  ggplot(aes(y=valor, x=as.factor(Y),fill=granulometria)) +
  geom_boxplot()+
  theme(axis.text.x=element_text(angle=90, hjus=1,size = rel(0.8)))
```

<!--chapter:end:10-AED.Rmd-->

`r if (knitr::is_html_output()) '
# Referências {-}

Andrade, P. F. & Ogliari, P. (2010) **Estatística para Ciências Agrárias e Biológicas e Noções de Experimentação**. Florianópolis, Ed.: UFSC.

Ascencio, A. F. G. & de Campos, E. A. V. (2007) **Fundamentos da programação de computadores**. 2 ed. ed.  São Paulo: Pearson Prentice Hall, 434 p.

Bussab, W. O. & Morettin, P. A. (2002) **Estatística Básica**. 5 ed.  São Paulo: Saraiva,   p.

Magalhães, M. N. & Lima, A. C. P. (2005) **Noções de Probabilidade e Estatística**.  São Paulo: Editora da Universidade de São Paulo, 392 p.

Crawley, M. J. (2007) **The R Book**. UK, Ed. Willey & Sons Ltda, 950 p. (pdf).

Forbellone, A. L. V. & Eberspächer, H. F. (2005) **Lógica de programação: a construção de algoritmos e estruturas de dados**. 3 ed ed.  São Paulo: Pearson Prentice Hall, 218 p.

Long, J. D. & Teetor, P. (2019) **R Cookbook**. USA: O’Reilly Media, Inc, https://rc2e.com/.

Peternelli, L. A. & Mello, M. P. (2011) **Conhecendo o R: uma visão estatística**. 2ª ed. Viçosa, MG, Ed. UFV, 185 p.

Pimentel-Gomes,  F. (2000) **Curso de Estatística Experimental**. 10ª ed. Piracicaba, SP, Brasil: F. Pimentel-Gomes,  477 p.

Vieira, S. (1999) **Estatística experimental**. 2ª ed. São Paulo, Ed.: Editora Atlas S.A, 185 p. 

Wickham, H. & Grolemund G. (2019) **R for Data Science**. https://r4ds.had.co.nz/.
'`

<!--chapter:end:15-references.Rmd-->

