[
["index.html", "Análise de Dados de Ciência do Solo no R Bem-vindos!!", " Análise de Dados de Ciência do Solo no R Alan R. Panosso alan.panosso@unesp.br &amp; Gener T. Pereira gener.t.pereira@unesp.br 01 a 12 de Fevereiro de 2021 Bem-vindos!! As análises estatísticas e modelagem matemática são amplamente utilizadas na área da Agronomia na Ciência do Solo. Nesse contexto, a correta utilização dos recursos computacionais para decisão e execução das principais técnicas estatísticas e matemáticas é fundamental para a formação do estudante ao nível de pós-graduação, visando uma boa condução das análises de suas pesquisas. Neste contexto, a Ciência de Dados tem destaque mundial, uma vez que todos os campos de estudo e áreas de negócios foram afetados à medida que as pessoas percebem cada vez mais o valor das incríveis quantidades de dados sendo gerados. Mas para extrair valor desses dados, é necessário ser treinado nas habilidades adequadas de ciência de dados. A linguagem de programação R (software livre, de domínio público) se tornou a linguagem de programação de fato para a ciência de dados. Sua flexibilidade, potência, sofisticação e expressividade a tornaram uma ferramenta inestimável para cientistas de dados em todo o mundo. Neste curso pretende-se dar uma introdução às técnicas de programação e à riqueza do ambiente R, destinada aos pós-graduandos iniciantes e intermediários da estatística e da experimentação agronômica e, consequentemente, da ciência de dados. Inicialmente serão abordados tópicos de programação R, para a familiarização dos alunos às estruturas básicas e recursos de programação e visualização de dados. Em seguida serão abordados os temas de estatística descritiva, teste de hipóteses, análise de regressão, análise de variância, e rotinas de diagnósticos, todos desenvolvidos no ambiente R. Você começará com o básico da linguagem, aprenderá como manipular conjuntos de dados, como escrever funções, como visualizar seus dados e como analizá-los. Com os fundamentos fornecidos neste curso, esperamos que você tenha uma base sólida sobre a qual construir sua caixa de ferramentas de ciência de dados na ciência do solo, ou em em sua área de atuação. "],
["ambientação.html", "1 Ambientação 1.1 Instalando o R 1.2 Instalando o RStudio", " 1 Ambientação 1.1 Instalando o R Faça o download do R do site oficial The R Project for Statistical Computing https://www.r-project.org/ Acesso rápido: Download Salve o arquivo de instalação em um diretório de seu computador e em seguida execute-o. O processo é simples e intuitivo. 1.2 Instalando o RStudio É um ambiente de desenvolvimento integrado (IDE) para o R, disponível em https://rstudio.com/products/rstudio/download/ Escolha o instalador de acordo com o seu sistema operacional. Windows no nosso caso. Novamente, salve o arquivo de instalação em um diretório de seu computador e em seguida execute-o. Após a instalação procure o ícone do R criado pelo instalador e clique nele. Um breve tutorial para instalação do R e do RStudio pode ser encontrado no vídeo abaixo. "],
["pacotes-no-r.html", "2 Pacotes no R 2.1 Pacotes básicos 2.2 Instalando pacotes", " 2 Pacotes no R Um pacote é uma coleção de funções, exemplos e documentação. A funcionalidade de um pacote é frequentemente focada em uma metodologia estatística especial\" (Everitt &amp; Hothorn). Figure 2.1: Pacotes no R são coleções de funções, exemoplos e documentações, os quais devem ser previamente instalados e alocados no ambiente por meio da função library ou require. 2.1 Pacotes básicos Liste os pacotes carregados no ambiente com: (.packages()) ## [1] &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [7] &quot;base&quot; O retorno da função é uma lista de nomes, caracteres (ou strings), na forma de um objeto denominado vetor. Observe que cada pacote (elemento) é referenciado dentro do vetor por um índice, um número inteiro \\([\\;i\\;]\\) apresentado entre colchetes [i], onde \\(i\\) varia de \\(1\\) a \\(7\\), em nosso exemplo, pois sete é o número total de elementos do vetor. Carregue um pacote chamando a função library. library(MASS) Ou utilize a função require. require(car) Agora, liste novamente os pacotes e observe a diferença no retorno da função. (.packages()) ## [1] &quot;car&quot; &quot;carData&quot; &quot;MASS&quot; &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; ## [7] &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; &quot;base&quot; 2.2 Instalando pacotes Para a realização de vários procedimentos estatístico e manipulação de arquivos durante o curso, serão necessários vários pacotes que não fazem parte do base do R, que deverão ser instalados. Utilizando a opção Install/Packages Instale alguns pacotes: tidyverse agricolae readxl stringr lubridate Os pacotes também podem ser instalados a partir das linhas de comandos (códigos): install.packages(&quot;tidyverse&quot;) install.packages(&quot;agricolae&quot;) install.packages(&quot;readxl&quot;) install.packages(&quot;stringr&quot;) install.packages(&quot;lubridate&quot;) "],
["lógica-de-programação.html", "3 Lógica de Programação 3.1 Introdução 3.2 Conceitos básicos", " 3 Lógica de Programação 3.1 Introdução A Lógica pode ser definida como a análise das formas e leis do pensamento, mas não se preocupa com a produção do pensamento, não se preocupa com o conteúdo do pensamento, mas sim com a maneira pela qual os pensamentos são organizados e apresentados, possibilitando que cheguemos a uma conclusão por meio do encadeamento dos argumentos. A lógica é a ciência que estuda as leis do raciocínio. Correção/validação do pensamento. Encadeamento/ordem de ideias. Arte de bem pensar. 3.2 Conceitos básicos Em Lógica um conceito importante é o de “Proposição”. Proposição: é um enunciado verbal, ao qual deve ser atribuído, sem ambiguidade, um valor lógico verdadeiro (\\(V\\) ou \\(TRUE\\)) ou falso (\\(F\\) ou \\(FALSE\\)). Abstração: Operação mental que observa a realidade e captura apenas os aspectos relevantes para um contexto. Figure 3.1: Passe alguns segundos olhando para a figura abaixo e diga o que você consegue abstrair dela. Perceba que a realidade é a mesma, isto é, uma figura em preto e branco, mas, dependendo da observação da realidade, você pode ter abstrações diferentes. Por isso, a abstração depende mais do observador do que da realidade observada. A tarefa de programar sistemas computacionais envolve o exercício constante da abstração da realidade e sua codificação em uma linguagem de programação. Programação: A tarefa de programar sistemas computacionais e envolve o exercício constante da abstração da realidade e sua codificação em uma linguagem de programação. Figure 3.2: Exemplo de programação de um sistema para exibir a média de dois números #Entrada a&lt;-6 b&lt;-8 #Processamento resultado &lt;- (a+b)/2 #Saída resultado ## [1] 7 Linguagem de Programação: conjunto de palavras e regras que permitem comunicar ao computador o que este deve executar. Em computação, uma linguagem de programação é a ferramenta de comunicação entre o programador que visa resolver um problema e o computador que irá ajudá-lo a resolver. Tipos de linguagens de programação: 1 - Totalmente codificadas em binário (0´s e 1´s). 2 - Usa instruções simbólicas para representar os 0´s e 1´s. 3 - Voltadas para facilitar o raciocínio humano. Figure 3.3: Resumo dos tipos de linguagem de programação. Se o computador só entende linguagem de máquina, o que deve ser feito para que ele entenda programas em linguagem assembly ou de alto nível? Tradutores no contexto de linguagens de programação são programas que recebem como entrada um programa em linguagem assembly ou de alto nível (dita linguagem fonte) e produzem como saída as instruções deste programa traduzidas para linguagem de máquina. Existem basicamente três tipos de tradutores: + Compilador + Interpretador + Assembler Figure 3.4: O Compilador traduz de uma vez só todo o programa escrito em linguagem de alto nível (código-fonte) para um programa equivalente escrito em linguagem de máquina (código-objeto). Por sua vez, o Interpretador, como o R, traduz (sem gerar código-objeto) e em seguida executa, uma-a-uma, as instruções de um programa em linguagem de alto nível (código-fonte). "],
["introdução-à-ciência-dos-dados.html", "4 Introdução à Ciência dos Dados 4.1 Importação 4.2 Organização 4.3 Transformação dos dados 4.4 Visualização 4.5 Modelação 4.6 Comunicação 4.7 Programação", " 4 Introdução à Ciência dos Dados A Ciência dos Dados, ou Data Science, é uma área interdisciplinar voltada para o estudo e a análise de dados, estruturados e não-estruturados, que visa a extração de conhecimento, detecção de padrões e/ou obtenção de variáveis para possíveis tomadas de decisão. O modelo base das ferramentas necessárias em um projeto típico de ciência dos dados é parecido com isso: Figure 4.1: Modelo base de um projeto de Ciência dos Dados. 4.1 Importação Primeiro devemos importar os dados no R. Ou seja, pegar os dados armazenados em um arquivo, base de dados ou na Web e carregá-los em uma estrutuda de dados no R. Sem eles no R, não conseguiremos fazer Data Science. Para essa prática, vamos utilizar um banco de dados oriundo de um estudo geomorfológico. Importação via web Acesse o banco de dados na web: Clique no link para o arquivo geomorfologia.txt. # definir o caminho URL &lt;- &quot;https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/geomorfologia.txt&quot; # Importação dados&lt;-read.table(URL, header = TRUE) # Argumento para cabeçalho na primeira linha # Inspeção do banco de dados head(dados) # mostra o 6 primeiros registros ## SUP Solo Amostra X AMG AG AM AF AMF SILTE ARGILA S_A AF_AG P pH ## 1 I LV 1 0 0.2 3.72 20.4 22.9 30.0 1.2 21.5 0.05 6.16 42 4.2 ## 2 I LV 2 25 0.1 4.27 22.6 23.6 28.4 1.2 20.4 0.05 5.53 22 3.8 ## 3 I LV 3 50 0.7 5.00 22.7 22.2 26.9 1.2 21.4 0.05 4.44 41 4.8 ## 4 I LV 4 75 0.4 3.80 23.7 24.4 26.7 0.6 20.5 0.02 6.42 27 4.0 ## 5 I LV 5 100 0.4 3.10 22.3 24.6 26.9 2.1 20.7 0.10 7.94 11 4.4 ## 6 I LV 6 125 0.4 3.80 23.8 19.1 27.1 2.2 23.5 0.09 5.03 12 4.0 ## K Ca Mg H_Al SB T V ## 1 0.27 1.4 0.3 5.2 1.97 7.17 27 ## 2 0.11 0.4 0.1 5.8 0.61 6.41 10 ## 3 0.34 2.4 0.4 4.2 3.14 7.34 43 ## 4 0.13 0.7 0.1 5.2 0.93 6.13 15 ## 5 0.11 1.4 0.3 4.2 1.81 6.01 30 ## 6 0.14 0.6 0.1 5.2 0.84 6.04 14 Importação via Excel Acesse o banco de dados para essa prática, denominado geomorfologia.xlsx, salve o arquivo em uma pasta de seu computador. Figure 4.2: Na aba Environment selecione a opção Import Dataser e escolha From Excel… Figure 4.3: 1) Clique em Browse…, acesse a pasta na qual você salvou o arquivo; 2) selecione o arquivo geomorfologia.xlsx; 3) clique em Open. Figure 4.4: Pré-visualização dos dados, observe que o código de importação é apresentado abaixo dessa janela. Copie esse código, e clique em CANCEL. Cole as linhas de código no script do R e as execute, para ter a importação dos dados. library(readxl) geomorfologia &lt;- read_excel(&quot;C:/GitHub/r_data_science_fcav/dados/geomorfologia.xlsx&quot;) View(geomorfologia) Figure 4.5: Após executar o código, os dados devem ser apresentados dessa forma. 4.2 Organização Uma vez que os dados estão no R, a próxima etapa é organizá-los, ou seja, armazená-los de uma forma consistente que combine a semântica da base de dados com a maneira com a qual eles são armazenados. Cada coluna é uma variável e cada linha é uma observação. Figure 4.6: Exemplo de dados organizados em planilha eletrônica, onde cada coluna é uma variável e cada linha é uma observação, ou registro. Observação: O R, como a maioria dos softwares estatísticos, utiliza o ponto como separador decimal, ou seja, como o símbolo usado para separar a parte inteira da parte complementar não inteira da representação decimal do numeral de um real (ponto flutuante). Portanto, aconselhamos você a padronizar o separador decimal do seu computador. Para isso sigua os passos abaixo: Figure 4.7: Acesse o PAINEL DE CONTROLE, na opção REGIÃO clique em CONFIGURAÇÕES ADICIONAIS… e modifique o SÍBOLO DECIMAL para PONTO e o SÍMBOLO DE AGRUPAMENTO DE DÍGITO para VÍRGULA. Vamos conhecer a estrutura do nosso banco de dados, a partir da função str. str(dados) ## &#39;data.frame&#39;: 106 obs. of 22 variables: ## $ SUP : chr &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ... ## $ Solo : chr &quot;LV&quot; &quot;LV&quot; &quot;LV&quot; &quot;LV&quot; ... ## $ Amostra: int 1 2 3 4 5 6 7 8 9 10 ... ## $ X : int 0 25 50 75 100 125 150 175 200 225 ... ## $ AMG : num 0.2 0.1 0.7 0.4 0.4 0.4 1.2 0.8 1.1 1.2 ... ## $ AG : num 3.72 4.27 5 3.8 3.1 3.8 3.6 4.7 4.5 5.9 ... ## $ AM : num 20.4 22.6 22.7 23.7 22.3 23.8 23.1 25.8 25.5 32.8 ... ## $ AF : num 22.9 23.6 22.2 24.4 24.6 19.1 21.7 21.1 18.9 19.8 ... ## $ AMF : num 30 28.4 26.9 26.7 26.9 27.1 26.5 24.7 25.4 21.7 ... ## $ SILTE : num 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ... ## $ ARGILA : num 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ... ## $ S_A : num 0.05 0.05 0.05 0.02 0.1 0.09 0.03 0.01 0.11 0.01 ... ## $ AF_AG : num 6.16 5.53 4.44 6.42 7.94 5.03 6.03 4.49 4.2 3.36 ... ## $ P : num 42 22 41 27 11 12 11 16 38 25 ... ## $ pH : num 4.2 3.8 4.8 4 4.4 4 4.8 5.4 4.4 5.2 ... ## $ K : num 0.27 0.11 0.34 0.13 0.11 0.14 0.23 0.28 0.19 0.14 ... ## $ Ca : num 1.4 0.4 2.4 0.7 1.4 0.6 1.6 3.3 1.6 2.9 ... ## $ Mg : num 0.3 0.1 0.4 0.1 0.3 0.1 0.7 1.3 0.5 1.7 ... ## $ H_Al : num 5.2 5.8 4.2 5.2 4.2 5.2 3.4 2.5 5.2 3.1 ... ## $ SB : num 1.97 0.61 3.14 0.93 1.81 0.84 2.53 4.88 2.29 4.74 ... ## $ T : num 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ... ## $ V : num 27 10 43 15 30 14 43 66 31 60 ... Podemos identificar que os dados são compostos por 106 linhas e 22 colunas. As duas primeiras colunas são do tipo texto (chr - character) e as demais colunas são numéricas (num - numeric). 4.3 Transformação dos dados O termo transformação significa literalmente recortar o banco de dados, assim podemos focar nas observações de interesse. Criar novas variáveis em função das existentes e calcular, por exemplo, um resumo estatístico desse conjunto de interesse. Por exemplo, vamos selecionar somente os solos do tipo LV. # Criar um filtro f &lt;- dados$Solo == &quot;LV&quot; # Criar um banco de dados auxiliar da da &lt;- dados[f,] # Vamos ver a estrutura desse banco auxiliar str(da) ## &#39;data.frame&#39;: 16 obs. of 22 variables: ## $ SUP : chr &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ... ## $ Solo : chr &quot;LV&quot; &quot;LV&quot; &quot;LV&quot; &quot;LV&quot; ... ## $ Amostra: int 1 2 3 4 5 6 7 8 9 10 ... ## $ X : int 0 25 50 75 100 125 150 175 200 225 ... ## $ AMG : num 0.2 0.1 0.7 0.4 0.4 0.4 1.2 0.8 1.1 1.2 ... ## $ AG : num 3.72 4.27 5 3.8 3.1 3.8 3.6 4.7 4.5 5.9 ... ## $ AM : num 20.4 22.6 22.7 23.7 22.3 23.8 23.1 25.8 25.5 32.8 ... ## $ AF : num 22.9 23.6 22.2 24.4 24.6 19.1 21.7 21.1 18.9 19.8 ... ## $ AMF : num 30 28.4 26.9 26.7 26.9 27.1 26.5 24.7 25.4 21.7 ... ## $ SILTE : num 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ... ## $ ARGILA : num 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ... ## $ S_A : num 0.05 0.05 0.05 0.02 0.1 0.09 0.03 0.01 0.11 0.01 ... ## $ AF_AG : num 6.16 5.53 4.44 6.42 7.94 5.03 6.03 4.49 4.2 3.36 ... ## $ P : num 42 22 41 27 11 12 11 16 38 25 ... ## $ pH : num 4.2 3.8 4.8 4 4.4 4 4.8 5.4 4.4 5.2 ... ## $ K : num 0.27 0.11 0.34 0.13 0.11 0.14 0.23 0.28 0.19 0.14 ... ## $ Ca : num 1.4 0.4 2.4 0.7 1.4 0.6 1.6 3.3 1.6 2.9 ... ## $ Mg : num 0.3 0.1 0.4 0.1 0.3 0.1 0.7 1.3 0.5 1.7 ... ## $ H_Al : num 5.2 5.8 4.2 5.2 4.2 5.2 3.4 2.5 5.2 3.1 ... ## $ SB : num 1.97 0.61 3.14 0.93 1.81 0.84 2.53 4.88 2.29 4.74 ... ## $ T : num 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ... ## $ V : num 27 10 43 15 30 14 43 66 31 60 ... Vamos continuar o processo de filtragem e selecionar somente as colunas SUP, ARGILA, SILTE e T. da&lt;-da[,c(1,11,10,21)] str(da) ## &#39;data.frame&#39;: 16 obs. of 4 variables: ## $ SUP : chr &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ... ## $ ARGILA: num 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ... ## $ SILTE : num 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ... ## $ T : num 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ... Vamos criar uma nova variável, ARG_SILT a partir da soma dos valores de ARGILA + SILTE, para isso vamos utilizar o símbolo de acesso de colunas, o cifrão ($). Em seguida, aplicaremos a transformação logarítmica aos dados de T. da$ARG_SILT &lt;- da$ARGILA + da$SILTE da$Log_T &lt;- log10(da$T) str(da) ## &#39;data.frame&#39;: 16 obs. of 6 variables: ## $ SUP : chr &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ... ## $ ARGILA : num 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ... ## $ SILTE : num 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ... ## $ T : num 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ... ## $ ARG_SILT: num 22.7 21.6 22.6 21.1 22.8 25.7 23.8 22.9 24.5 18.7 ... ## $ Log_T : num 0.856 0.807 0.866 0.787 0.779 ... Agora vamos gerar um resumo estatístico para esses dados. A primeira coluna é do tipo texto, então, deve ser retirada do banco de dados auxiliar da antes de realizarmos os cálculos. Para isso, utilizamos o índice \\(-1\\) na dimensão das colunas do objeto da, ou seja, estamos retirando a coluna 1 SUP de da. # Número de observações apply(da[,-1],2,length) ## ARGILA SILTE T ARG_SILT Log_T ## 16 16 16 16 16 # Média apply(da[,-1],2,mean) ## ARGILA SILTE T ARG_SILT Log_T ## 21.1937500 1.2125000 6.2618750 22.4062500 0.7920605 # Mediana apply(da[,-1],2,median) ## ARGILA SILTE T ARG_SILT Log_T ## 20.8500000 1.1000000 6.0850000 22.6500000 0.7842487 # Variância apply(da[,-1],2,var) ## ARGILA SILTE T ARG_SILT Log_T ## 2.101958333 0.782500000 0.890589583 3.015291667 0.004318016 # Desvio Padrão apply(da[,-1],2,sd) ## ARGILA SILTE T ARG_SILT Log_T ## 1.44981321 0.88459030 0.94371054 1.73645952 0.06571161 # Podemos utilizar a função summary. summary(da[,-1]) ## ARGILA SILTE T ARG_SILT ## Min. :18.50 Min. :0.200 Min. :4.840 Min. :18.70 ## 1st Qu.:20.48 1st Qu.:0.475 1st Qu.:5.760 1st Qu.:21.32 ## Median :20.85 Median :1.100 Median :6.085 Median :22.65 ## Mean :21.19 Mean :1.212 Mean :6.262 Mean :22.41 ## 3rd Qu.:22.18 3rd Qu.:2.125 3rd Qu.:7.213 3rd Qu.:23.20 ## Max. :23.50 Max. :2.600 Max. :7.840 Max. :25.70 ## Log_T ## Min. :0.6848 ## 1st Qu.:0.7598 ## Median :0.7842 ## Mean :0.7921 ## 3rd Qu.:0.8581 ## Max. :0.8943 Agora podemos gerar o conhecimento, por meio da Visualização e Modelagem. Essas tem suas vantegens e desvantagens as quais são complementares, portanto, quaisquer análises reais farão muitas vezes iteraçoes entre elas. Figure 4.8: Visualização e modelagem são dois processos iterativos, onde a matemática é uma ferramenta essencial para a extração de padrões, declaração e testes de hipóteses. 4.4 Visualização Atividade fundamentalmente humana, uma boa visualização lhe mostrará coisas que não esperava, ou levantará novas questões sobre os dados. Além disso, pode mostrar também que você esta fazendo a pergunta errada, ou que precisa coletar dados diferentes. Visualizações podem surpreender o analista de dados, mas não escalam particularmente bem, por que requerem um humano para interpretá-las. plot(da$ARGILA,da$T) 4.5 Modelação Modelo são ferramentas complementares da visualização. Uma vez que você tenha feito perguntas suficientemente precisas, poderá usar um modelo para respondê-las. Modelos são fundamentalmente matemáticos ou computacionais, então, geralmente escalam muito bem. Porém, cada modelo faz suposições e, por sua própria natureza, não podem questionar suas própria hipóteses, ou seja, um modelo não pode nos surpreender. plot(da$ARGILA,da$T) mod&lt;-lm(da$T~da$ARGILA) summary.lm(mod) ## ## Call: ## lm(formula = da$T ~ da$ARGILA) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.4256 -0.4641 -0.1615 0.9560 1.5268 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 6.66574 3.69347 1.805 0.0927 . ## da$ARGILA -0.01906 0.17389 -0.110 0.9143 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9764 on 14 degrees of freedom ## Multiple R-squared: 0.000857, Adjusted R-squared: -0.07051 ## F-statistic: 0.01201 on 1 and 14 DF, p-value: 0.9143 abline(mod) 4.6 Comunicação É a última etapa do Data Science, a mais importante. Não importa quão bem seus modelos e visualizações o levaram a entender os dados, a menos que você também consiga comunicar seus resultados para outras pessoas. Uma dica importante, é estudar RMarkdown! Ótima linguagem de marcação de texto, utilizada para gerar relatórios em HTML, .doc e pdf. Inclusive, esse material que estamos utilizando no curso. Figure 4.9: https://bookdown.org/yihui/rmarkdown-cookbook/ 4.7 Programação Permeia todas as etapas da Ciência dos Dados. Ao nosso ver é uma questão recursiva… O computador é a ferramenta do cientista de dados. R é um ambiente e linguagem de programação de código aberto para computação estatística, bioinformática e gráficos. Como linguagem de programação, garante a reprodutibilidade das análises. Estudantes podem usar as mesmas ferramentas que os profissionais. Todos podem usar as melhores ferramentas independente do poder financeiro. Qualquer um pode reproduzir as suas análises. Você pode corrigir problemas. Você pode desenvolver suas próprias ferramentas. Linguagem orientada a objetos R (Ross Ihaka e Robert Gentleman). R é uma poderosa linguagem, flexível e possui excelentes facilidades gráficas. R é um projeto open-source e está disponível na internet sobre a General Public License (&lt;www.gnu.org/copyleft/gpl.html&gt; e &lt;www.fsf.org&gt;). "],
["tópicos-iniciais.html", "5 Tópicos iniciais 5.1 Identificadores 5.2 Palavras Reservadas 5.3 Regras para os nomes de Identificadores 5.4 Tipos de dados 5.5 Atribuição 5.6 Operadores 5.7 Operação aritmética 5.8 Funções matemáticas e trigonométricas 5.9 Operações Relacionais 5.10 Operações Lógicas 5.11 Exercícios", " 5 Tópicos iniciais 5.1 Identificadores São nomes únicos definidos pelos programadores para identificar/distinguir os elementos de um programa. 5.2 Palavras Reservadas São instruções primitivas que têm significados pré-determinados e fazem parte da estrutura de qualquer linguagem de programação. 5.3 Regras para os nomes de Identificadores 1) Devem começar por um caractere alfabético; 2) Podem ser seguidos por mais caracteres alfabéticos e/ou numéricos; 3) Não é permitido o uso de espaço em branco ou de caracteres especiais, como: @, #, &amp;, ?, $ (exceto o _ e o .); 4) Não poderá ser uma palavra reservada a uma instrução do algoritmo (if, else, for, while, entre outras); *5) Devem ser significativos. Geralmente, desejamos que os nomes dos objetos sejam descritivos, então precisaremos de uma convenção para várias palavras. Recomendamos snake_case, onde você separa palavras minúsculas com _ . eu_uso_snake_case outrasPessoasUsamCamelCase algumas.pessoas.usam.pontos E_algumasPoucas.Pessoas_RENUNCIAMconvenções 5.4 Tipos de dados As fases de Entrada, Processamento e Saída podem manipular vários tipos primitivos de dados, a saber: Figure 5.1: Tipos primitivos de dados Um Caractere SEMPRE deve estar entre aspas duplas \" \" ou simples ’ ’. Por exemplo: \"A\", \"Fone 3333-33333\", \"1\", '3.1415', 'a mais bonita',etc. &quot; Olá, eu sou um texto.&quot; ## [1] &quot; Olá, eu sou um texto.&quot; &#39;1&#39; # não pode ser feito cálculos ## [1] &quot;1&quot; 3.14 # DOUBLE: valor real, de ponto flutuante. ## [1] 3.14 1 # valor numérico inteiro, ## [1] 1 4L #sufixo L temos números inteiros em vez de double ## [1] 4 pi # constante pré definida com o valor de pi ## [1] 3.141593 TRUE # valor lógico verdadeiro ## [1] TRUE FALSE # valor lógico falso ## [1] FALSE 5.5 Atribuição Serve para atribuir um valor a uma variável/objeto no R. A expressão do lado direito do operador é avaliada e seu resultado é armazenado na variável à esquerda. O operador de atribuição pode ser o &lt;- ou o =, preferencialmente utilizaremos o &lt;- para a criação dos objetos e deixaremos o = para a definição de valores em argumentos dentro da funções. O atalho para o símbolo de atribuição é ALT+\\(-\\). texto&lt;-&quot; Olá, eu sou um texto.&quot; x_chr&lt;-&quot;1&quot; # não pode ser feito cálculo c&lt;-1 # valor numérico inteiro PI&lt;-3.14 # valor real, de ponto flutuante logico_1&lt;-TRUE # valor lógico logico_2&lt;-FALSE # valor lógico 5.6 Operadores Aritméticos: são as operações aritméticas básicas. Operador Tipo Operação Prioridade - Unário Inversão do Sinal 1 + Unário Manutenção do Sinal 1 sqrt(x) Binário Radiciação 2 x^y ou x**y Binário Potenciação 2 % Binário Resto da divisão inteira 3 / Binário Divisão 3 * Binário Multiplicação 3 - Binário Subtração 4 + Binário Adição 4 Relacionais: são operadores binários (de mesma prioridade) que somente retornam os valores lógicos Verdadeiro (TRUE) ou Falso (FALSE). Operador Comparação &gt; maior que &lt; menor que &gt;= maior ou igual &lt;= menor ou igual == igual a != diferente de Estes somente são usados para efetuar comparações, as quais só podem ser feitas entre dados do mesmo tipo. O resultado de uma comparação é sempre um valor lógico V (TRUE) ou F(FALSE). Lógicos ou Booleanos: são usados para combinar expressões relacionais e lógicas. Também retornam como resultado valores lógicos Verdadeiro (TRUE) ou Falso (FALSE). Operador Tipo Operação Prioridade NÃO (!) Unário Negação 1 E (&amp;) Binário Conjunção 2 OU (|) Binário Disjunção 3 5.7 Operação aritmética \\[ \\begin{aligned} &amp; a) 1+7 = 8\\\\ &amp; b)1 - 2 \\times10 = 19\\\\ &amp; c) 2^{10} = 1024\\\\ &amp; d) \\frac{10}{3} = 3,33333 \\end{aligned} \\] 1 + 7 1 - 2 * 10 2 ** 10 10/3 5.8 Funções matemáticas e trigonométricas \\[ \\begin{aligned} &amp; a)\\;\\sqrt{9} = 3\\\\ &amp; b)\\;seno\\;\\pi = 0\\\\ &amp; c)\\;5! =120\\\\ &amp; d)\\; e^5 = 148,4132 \\\\ &amp; e=2,718282 \\end{aligned} \\] sqrt(9) sin(pi) factorial(5) exp(5) exp(1) 5.9 Operações Relacionais \\[ \\begin{aligned} &amp; a)\\;7 &gt; 5 \\text{ retorna &#39;verdadeiro&#39;}\\\\ &amp; b)\\;8 \\leq 4 \\text{ retorna &#39;falso&#39;}\\\\ &amp; c)\\;5 = \\frac{25}{5} \\text{ retorna &#39;verdadeiro&#39;}\\\\ &amp; d)\\; 4\\neq 8 \\text{ retorna &#39;verdadeiro&#39;} \\end{aligned} \\] 7 &gt; 5 ; 4 != 8 ## [1] TRUE ## [1] TRUE nome &lt;- &#39;Alan&#39; nome == &#39;Rodrigo&#39; ## [1] FALSE nome == &quot;Alan&quot; ## [1] TRUE 5.10 Operações Lógicas \\[ \\begin{aligned} &amp; a)\\;7 &gt; 5 \\; OU \\; 8 \\leq 4 \\text{ retorna &#39;verdadeiro&#39;}\\\\ &amp; b)\\;5 = \\frac{25}{5} \\; E \\; 4 &gt; 8 \\text{ retorna &#39;falso&#39;} \\\\ &amp; c) \\text{ Não} \\; \\text{TRUE}\\; \\text{retorna &#39;falso&#39;} \\\\ &amp; d) \\text{ Não} \\; \\text{FALSE} \\; \\text{retorna &#39;verdadeiro&#39;} \\end{aligned} \\] 7 &gt; 5 | 8 &lt;= 4 5 == 25/5 &amp; 4 &gt; 8 !TRUE !FALSE x &lt;- c(1, 4, 2, NA, 8) is.na(x) x[!is.na(x)] 5.11 Exercícios Resolva as seguintes expressões: \\[ \\begin{aligned} &amp; a)\\; log\\;3 \\\\ &amp; b)\\; ln\\;10\\\\ &amp; c)\\; e^{2,302585}\\\\ &amp; d)\\; \\sqrt{225}\\\\ &amp; e)\\; 5!\\\\ &amp; f)\\; seno\\;30°\\\\ \\end{aligned} \\] Algumas funções do R Função Significado/ação q() Sair do programa. save.image() Salva o trabalho realizado. ls() Lista todos os objetos da área de trabalho atual. rm(x) Remove o objeto x. rm(x,y) Remove os objetos x e y. rm(list=ls(all=TRUE)) Remove todos os objetos (R Console – Misc/Remover todos os objetos). is.na(x) Verdadeiro se existir dado(s) ausente(s) no objeto x. sqrt(x) raiz quadrada de x. log(x,n) logaritmo de x na base n. log(x) logaritmo neperiano de x. log10(x) logaritmo decimal de x. exp(x)|antilogaritmo - ex. sin(x)|seno de x (em radianos). asin(x)|arco-seno de x. abs(x)|modulo(x). factorial(x)|x !. floor(x)|maior inteiro &lt; x. ceiling(x)|menor inteiro &gt;x. trunc(x)|inteiro de x, descartando seus decimais. round(x, digits=0)|arredondando o valor x para um inteiro. signif(x, digits=6)|apresentar 6 dígitos significativos de x. runif(n)|gera n números aleatórios entre 0 e 1 a partir de uma distribuição uniforme. c()|concatenação, criação de vetores. "],
["algoritmos.html", "6 Algoritmos 6.1 Estruturas de Controle 6.2 Exercícios", " 6 Algoritmos Definição: Sequência lógica e não ambígua de instruções que levam à solução de um problema num tempo finito. -Sequência lógica: As instruções devem ser definidas em uma ordem correta. -Não ambígua: A sequência lógica e as instruções não devem dar margem à dupla interpretação. -Solução de um problema: A sequência lógica deve resolver exatamente (nem mais e nem menos) o problema identificado. -Tempo finito: A sequência lógica não deve possuir iterações infinitas. -Um algoritmo é “uma solução” e não “a solução” de um problema. -Um problema pode ser resolvido por mais de um algoritmo! SEMPRE. -Tarefas que possuem “padrão de comportamento” podem ser descritas por um algoritmo. Entender algoritmos é fundamental para desenvolver o raciocínio lógico e conceber uma solução a um dado problema, independente de uma linguagem de programação. (Ex: Fortran, Pascal, C e Python, R). A partir do algoritmo desenvolvido, fica mais fácil implementar o respectivo programa. 6.1 Estruturas de Controle Na criação de algoritmos, utilizamos os conceitos de bloco lógico, entrada e saída de dados, variáveis, constantes, atribuições, expressões lógicas, relacionais e aritméticas, bem como comandos que traduzam esses conceitos de forma a representar o conjunto de ações. Para que esse conjunto de ações se torne viável, deve existir uma perfeita relação lógica intrínseca ao modo pelo qual essas ações são executadas, ao modo pelo qual é regido o fluxo de execução do algoritmo. Por meio das estrutura básicas de controle do fluxo de execução – sequencial, seleção, repetição e da combinação delas – poderemos criar algoritmos para solucionar vários problemas. Estruturas básicas de um algoritmo: 6.1.1 Sequêncial Representa o Início/Fim, e define uma estrutura onde as instruções serão executadas na ordem que aparecem. Corresponde ao fato de que o conjunto de ações primitivas será executado em uma sequência linear de cima para baixo da esquerda para a direita. Para exemplificarmos, vamos resolver o seguinte exercício. Exemplo: Vamos construir um algoritmo que calcule a média aritmética entre quatro notas bimestrais fornecidas: # Entrada n1 &lt;- 4 n2 &lt;- 5 n3 &lt;- 6 n4 &lt;- 7 # Processamento media &lt;- (n1+n2+n3+n4) / 4 # Saída media ## [1] 5.5 6.1.2 Seleção a) Se-Então/Senão Define uma estrutura condicional que, dada a sua avaliação (Verdadeira ou Falsa), determina qual “caminho” do algoritmo será executado. Permite a escolha de um grupo de ações (bloco) a ser executado quando determinadas condições, representadas por expressões lógicas e/ou relacionais, são satisfeitas ou não. Os tipo de seleção apresentados serão: Simples, Composta e Encadeada. Exemplo - Seleção Simples: Classifique um valor qualquer fornecido X, se é maior que zero. Quando precisamos testar uma certa condição antes de executar uma ação. X &lt;- 7 if(X &gt; 0) { # Início do bloco Verdadeiro print(&quot;Valor maior que zero&quot;) } # Final do bloco Verdadeiro ## [1] &quot;Valor maior que zero&quot; OBS: Quando houver somente uma ação primitiva, a estrutura pode ser: X &lt;- 7 if(X &gt; 0) print(&quot;Valor maior que zero&quot;) ## [1] &quot;Valor maior que zero&quot; Contudo, se atribuírmos um valor negativo a X, esse algoritimo não apresentará retorno. X &lt;- -5 if(X &gt; 0) print(&quot;Valor maior que zero&quot;) Exemplo - Seleção Composta: Classifique um valor qualquer fornecido X, se é maior que zero, ou menor ou igual a zero. Utilizadas em situações em que duas alternativas dependem de uma mesma condição: uma da condição VERDADEIRA, e outra da condição FALSA. X &lt;- -0.8987 if(X &gt; 0){ print(&quot;Valor maior que zero&quot;) }else{ # Início do bloco Falso print(&quot;Valor menor ou igual a zero&quot;) } # Fim do bloco Falso ## [1] &quot;Valor menor ou igual a zero&quot; Exemplo - Seleção Encadeada: Classifique um valor qualquer fornecido X, se é maior que zero, menor do que zero ou igual a zero. É o agrupamento de várias seleções, ocorre quanto uma determinada ação, ou bloco deve ser executado se um grande conjunto de possibilidades ou combinações de situações for satisfeito. X &lt;- 0.1 if(X &gt; 0){ print(&quot;Valor maior que zero&quot;) }else{ if(X&lt; 0 ){ print(&quot;Valor menor que zero&quot;) }else{ print(&quot;Valor igual a zero&quot;) } } ## [1] &quot;Valor maior que zero&quot; Observe que as etruturas acima apresentadas são funcionais para classificação de um único valor. Contudo para a classificação de vários valores em um vetor, recomenda-se o uso da função if_else do pacote dplyr disponível no tidyverse ou a função ifelse do pacote base do R. library(tidyverse) ## -- Attaching packages ----------------- tidyverse 1.3.0 -- ## v ggplot2 3.3.2 v purrr 0.3.4 ## v tibble 3.0.3 v dplyr 1.0.0 ## v tidyr 1.1.0 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.5.0 ## -- Conflicts -------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() ## x dplyr::recode() masks car::recode() ## x dplyr::select() masks MASS::select() ## x purrr::some() masks car::some() numeros &lt;- c(-0.8, 1, 5, 0, -4) if_else(numeros&lt;0,&quot;Negativo&quot;,if_else(numeros==0,&quot;Nulo&quot;,&quot;Positivo&quot;)) ## [1] &quot;Negativo&quot; &quot;Positivo&quot; &quot;Positivo&quot; &quot;Nulo&quot; &quot;Negativo&quot; ifelse(numeros&lt;0,&quot;Negativo&quot;,if_else(numeros==0,&quot;Nulo&quot;,&quot;Positivo&quot;)) ## [1] &quot;Negativo&quot; &quot;Positivo&quot; &quot;Positivo&quot; &quot;Nulo&quot; &quot;Negativo&quot; b) Selecione caso Muitas vezes nos deparamos com situações onde são necessários duas ou mais operações condicionais para classificação. Nessa situações poderemos utilizar a estrutura Selecione caso, que no R pode ser acessada com a função case_when (do pacote dplyr). Essa função é útil para vetorizar instruções condicionais. Isso é semelhante a if_else mas pode gerar qualquer número de valores, em vez de apenas TRUE ou FALSE. Aqui está um exemplo que retorna o dia da semana em função do número de 1 a 7, onde qualquer valor fora desse intervalo seja classificado como número inválido. dia &lt;- c(0,1,2,3,4,5,6,7,8) case_when( dia == 1 ~ &quot;Domingo&quot;, dia == 2 ~ &quot;Segunda-feira&quot;, dia == 3 ~ &quot;Terça-feira&quot;, dia == 4 ~ &quot;Quarta-feira&quot;, dia == 5 ~ &quot;Quinta-feira&quot;, dia == 6 ~ &quot;Sexta-feira&quot;, dia == 7 ~ &quot;Sábado&quot;, TRUE ~ &quot;número inválido&quot; ) ## [1] &quot;número inválido&quot; &quot;Domingo&quot; &quot;Segunda-feira&quot; &quot;Terça-feira&quot; ## [5] &quot;Quarta-feira&quot; &quot;Quinta-feira&quot; &quot;Sexta-feira&quot; &quot;Sábado&quot; ## [9] &quot;número inválido&quot; 6.1.3 Repetição Enquanto, Faça-Enquanto ou Para Define uma estrutura de iteração condicional (V ou F) ou contada (pré-definida) de instruções. É uma estrutura da controle do fluxo de execução que permite repetir diversas vezes um mesmo trecho do algoritmo, porém, sempre verificando ANTES de cada execução se é ‘permitido’ executar o mesmo trecho. a) Repetição com teste no Início O Enquanto (while) permite que um determinado comando (ou bloco) seja repetido enquanto uma determinada for VERDADEIRA. Muitas vezes precisamos estabelecer um modo de contagem (contador), ou seja, uma variável (\\(i\\) por exemplo) com um dado valor inicial que é incrementado a cada repetição. Quando o resultado da for FALSO o comando de repetição é abandonado. Se na primeira vez o resultado for FALSO, os comandos NÃO SÃO EXECUTADOS. Exemplo: Imprima os números menores ou iguais a 10. i=1 while(i&lt;=10){ print(i) i=i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 b) Repetição com teste no Final Uma das estruturas com teste no final é a Repita (repeat), que permite que um comando, ou bloco de comandos sejam executados enquanto uma determinada seja FALSA. Verificamos que, devido a sua sintaxe os comandos dentro do bloco São Executados Pelo Menos Uma Vez, independentemente da validade da condição. Isso ocorre pois a inspeção da ocorre no FINAL da estrutura. Quando o resultado da for VERDADEIRO o comando de repetição é abandonado. Entretanto, os comandos SÃO EXECUTADOS PELO MENOS UMA VEZ. Exemplo: Imprima os números menores ou iguais a 10. Observe que utilizamos o comando break juntamente com o a estrutura if, ou seja, se a for verdadeira o break interromperá a iteração o controle flui para fora do laço. i=1 repeat{ print(i) i=i+1 if(i&gt;10) break } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 c) Repetição com Variável de Controle As estruturas while e repeat ocorrem em casos de difícil determinação do número de vezes que um comando, ou bloco, será executado. A Estrutura Para (for) é diferente, já que sempre repete a execução do bloco um número pré-determinado de vezes, pois ela não prevê uma condição e possui limites fixos. Exemplo: Imprima os números menores ou iguais a 10. for(i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Exemplo: Elabore um algoritmo que, utilizando uma das estruturas de repetição imprima a tabuada do número 5. for(i in 1:10){ print(paste(&quot;5 x&quot;,i,&quot;=&quot;,i*5)) } ## [1] &quot;5 x 1 = 5&quot; ## [1] &quot;5 x 2 = 10&quot; ## [1] &quot;5 x 3 = 15&quot; ## [1] &quot;5 x 4 = 20&quot; ## [1] &quot;5 x 5 = 25&quot; ## [1] &quot;5 x 6 = 30&quot; ## [1] &quot;5 x 7 = 35&quot; ## [1] &quot;5 x 8 = 40&quot; ## [1] &quot;5 x 9 = 45&quot; ## [1] &quot;5 x 10 = 50&quot; 6.2 Exercícios 1) Crie uma script/função que peça dois números e imprima o maior deles. 2) Crie um script/função que peça um número e informe se o número é inteiro ou decimal. 3) Crie um script/função que leia um número de 1 a 7 e exiba o dia correspondente da semana. (1- Domingo, 2- Segunda, …, 7-Sábado.). Caso o usuário digitar um número diferente o programa deve escrever Valor invalido. 4) Crie um script/função que verifique se uma letra digitada é vogal ou consoante. 5) Crie um script/função que leia três números e mostre o maior e o menor deles. 6) Elabore um algoritmo que, classifique um número \\(X\\), fornecido pelo usuário, em par ou ímpar, utilize o operador % para o cálculo do resto da divisão. 7) Construa um algoritmo sequencial que calcule as raízes de uma equação do 2º grau (\\(ax^2 + bx + c\\)), sendo os valores de \\(a\\), \\(b\\) e \\(c\\) devem ser fornecidos pelo usuário. Considere: \\[ \\Delta = b^2-4 a c \\] se \\(\\Delta &gt; 0\\) \\[ x_1 = \\frac{-b+\\sqrt{\\Delta} }{2a} \\\\ x_2 = \\frac{-b-\\sqrt{\\Delta} }{2a} \\] se \\(\\Delta = 0\\) \\[ x= \\frac{-b}{2a} \\] se \\(\\Delta &lt; 0\\) As raízes são imaginárias 8) Faça um programa que imprima uma frase \\(n\\) vezes na tela do computador, \\(n\\) deve ser um número fornecido pelo usuário. 9) Faça um programa que imprima na tela os números de 1 a 20. 10) Faça um programa para obter as sequências de 0 a 25 com passo igual a 2. 11) Escreva um programa no qual o usuário digite dois números e o programa deve apresentar todos os números inteiros entre esses dois números. Se os números forem iguais, o programa deve exibir uma mensagem dizendo para o usuário digitar dois números inteiros diferentes. 12) Elabore um algoritmo que calcule e escreva o valor S, em que: \\[ S = 1 - \\frac{2}{4} + \\frac{3}{9} - \\frac{4}{16} + \\cdots - \\frac{10}{100} = 0,6456349 \\] 13) Construa um algoritmo que verifique se o número fornecido pelo usuário (inteiro maior que 1) é primo ou não (números primos são os números naturais que têm apenas dois divisores o 1 e ele mesmo, exemplo (2, 3, 5, 7, 11, 13, 17…). "],
["estrutura-de-dados.html", "7 Estrutura de dados 7.1 Atomic vector 7.2 Factor 7.3 Matrizes e Arrays 7.4 Listas 7.5 Data frames", " 7 Estrutura de dados A declaração de variáveis, uma a uma, é suficiente para a codificação algorítmica da solução de uma ampla gama de problemas, entretanto, esse tipo de declaração é insuficiente para resolver um grande número de problemas computacionais. A quantidade de tipos de dados primitivos (caractere, real, inteiro, lógico) não é suficiente para representar toda e qualquer informação que possa surgir. Assim, em muitas situações, esses recursos de representação são escassos, o que poderá ser suprimido se existisse mais tipos de dados ou, ainda melhor, se esses tipos pudessem ser construídos, à medida que fossem necessários. Portanto, vamos construir novos tipos de dados a partir da composição de tipos primitivos já estudados. Esses novos tipos tem o formato denominado estrutura de dados que define como os tipos primitivos são organizados. Tipos básicos de estrutura no R: Atomic vector: homogêneo e unidimensional Factor: homogêmeo e unidimensional Matriz: homogêneo e bidimensional Array: homogêneo e multidimensional Lista: heterogêneo Data frame: heterogêneo 7.1 Atomic vector Atomic vectors são a estrutura de objetos mais simples do R, caracterizados por “não terem dimensão.” Podem ser vistos como uma caixa com um rótulo ou nome colado a ela, que num dado instante guarda um determinado objeto, essa caixa pode ter seu conteúdo alterado diversas vezes. Tipos de atomic vectos: lógico integer double complexo character Figure 7.1: O objeto identificado como X possui um tipo numérico inteiro cujo valor é 5. (meu_inteiro &lt;- 5) ## [1] 5 (meu_double &lt;- 8.50) ## [1] 8.5 (meu_logico &lt;- TRUE) ## [1] TRUE (meu_char &lt;- &quot;A&quot;) ## [1] &quot;A&quot; De forma análoga, no conceito de estrutura de dados uma caixa poderá comportar não apenas uma e somente uma informação, a caixa comportará um conjunto de dados, desde que previamente organizada, ou seja, dividida em compartimentos. A função c(), o c é de concatenate utilizada para criação de um atomic vector com mais de um valor. Figure 7.2: O objeto identificado como X possui um tipo numérico inteiro cujos valores são 5, 8, 0, 2, 1 e 9. X &lt;- c(5,8,0,2,1,9) Y &lt;- c(0.5, 0.8, 1.5, 6.8) L &lt;- c(TRUE, FALSE, T, F) M &lt;- c(&quot;A&quot;, &quot;mais&quot;, &quot;bonita&quot;) As funções class() e mode() auxiliam na determinação do tipo de objeto. class(X) ## [1] &quot;numeric&quot; mode(X) ## [1] &quot;numeric&quot; class(M) ## [1] &quot;character&quot; mode(M) ## [1] &quot;character&quot; Observação: Coerção ocorre quando dois tipos de objetos são inseridos uma estrutura homogênea (atomic vectors, arrays ou matrizes), o R converterá o objeto para o tipo mais flexível, na ordem: 1-Lógico 2-Inteiro 3-Double 4-Caracter c(T,3,5.5,&quot;bela&quot;) ## [1] &quot;TRUE&quot; &quot;3&quot; &quot;5.5&quot; &quot;bela&quot; c(T,3,5.5) ## [1] 1.0 3.0 5.5 7.2 Factor Factors ou simplesmente Fatores são utilizados para armazernar dados categorizados e são caracterizados por conterem apenas valores pré-definidos, chamados de níveis do fator (levels) e se basearem num vetor de inteiros. Dentro do objeto, os levels são organizados em ordem alfabética. # Função factor trat&lt;-factor(c(&quot;T1&quot;,&quot;T1&quot;,&quot;T1&quot;,&quot;T2&quot;,&quot;T2&quot;,&quot;T2&quot;,&quot;T3&quot;,&quot;T3&quot;,&quot;T3&quot;)) trat ## [1] T1 T1 T1 T2 T2 T2 T3 T3 T3 ## Levels: T1 T2 T3 # Função gl (Generate factors levels) TRAT &lt;- gl(3,3, labels = c(&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;) ) TRAT ## [1] T1 T1 T1 T2 T2 T2 T3 T3 T3 ## Levels: T1 T2 T3 # Extraindo o níveis de um fator levels(trat) ## [1] &quot;T1&quot; &quot;T2&quot; &quot;T3&quot; 7.3 Matrizes e Arrays Matrizes e arrays são definidos usando as funções matrix() e array(), respectivamente. São multidimensionais. No caso da matriz esses objetos tem 2 dimensões e os compartimentos podem estar arranjados dessa maneira: Figure 7.3: O objeto identificado como X possui um tipo numérico inteiro bidimensional organizado na forma matricial com 6 linhas e 6 colunas totalizando 36 elementos. No R dois argumentos são utilizados na função matrix() um para determinar o número de colunas e a forma com a qual será o preeenchimento dos elementos na matriz, por linha (byrow=FALSE, default) ou por coluna (byrow=TRUE). Compare as duas matriz produzidas no exemplo abaixo. Preenchimento da matriz por coluna. mat1 &lt;- matrix(1:36, ncol = 6, byrow = FALSE) mat1 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 7 13 19 25 31 ## [2,] 2 8 14 20 26 32 ## [3,] 3 9 15 21 27 33 ## [4,] 4 10 16 22 28 34 ## [5,] 5 11 17 23 29 35 ## [6,] 6 12 18 24 30 36 Preenchimento da matriz por linha. mat2 &lt;- matrix(1:36, ncol = 6, byrow = TRUE) mat2 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 3 4 5 6 ## [2,] 7 8 9 10 11 12 ## [3,] 13 14 15 16 17 18 ## [4,] 19 20 21 22 23 24 ## [5,] 25 26 27 28 29 30 ## [6,] 31 32 33 34 35 36 Arrays são objetos que podem conter dois ou mais dados bidimensionais. Por exemplo, em matrizes quadradas podem conter duas linhas e duas colunas e a dimensão pode ter cinco. Os arrays podem armazenar os valores tendo apenas um tipo semelhante de tipos de dados. Os dados podem ser mais de uma dimensão, onde existem linhas e colunas e dimensões de algum comprimento. A função array() possui dois argumentos, data que receberá o vetor contendo os elementos e dim que receberá um vetor decrevendo o tamanho de cada dimensão. Vamos criar um array com duas matrizes de 4 linhas e 3 colunas: meu_array &lt;- array(1:24, c(4,3,2)) meu_array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 Os nomes das linhas, colunas e matrizes do array podem ser definidos a partir de uma lista aplicada ao argumento dimnames da função array(), como apresentado abaixo: linhas &lt;- c(&quot;Lin1&quot;, &quot;Lin2&quot;, &quot;Lin3&quot;, &quot;Lin4&quot;) colunas &lt;- c(&quot;Col1&quot;,&quot;Col2&quot;,&quot;Col3&quot;) matrizes&lt;- c(&quot;Matriz1&quot;, &quot;Matriz2&quot;) meu_array &lt;- array(1:24, c(4,3,2), dimnames = list(linhas,colunas, matrizes) ) meu_array ## , , Matriz1 ## ## Col1 Col2 Col3 ## Lin1 1 5 9 ## Lin2 2 6 10 ## Lin3 3 7 11 ## Lin4 4 8 12 ## ## , , Matriz2 ## ## Col1 Col2 Col3 ## Lin1 13 17 21 ## Lin2 14 18 22 ## Lin3 15 19 23 ## Lin4 16 20 24 Para saber qual é o tipo de um objeto, vamos utilizar as funções typeof() e class. # Array typeof(meu_array) ## [1] &quot;integer&quot; class(meu_array) ## [1] &quot;array&quot; # Matriz typeof(mat1) ## [1] &quot;integer&quot; class(mat1) ## [1] &quot;matrix&quot; &quot;array&quot; # Fator typeof(trat) ## [1] &quot;integer&quot; class(trat) ## [1] &quot;factor&quot; # Atomic vector typeof(Y) ## [1] &quot;double&quot; class(Y) ## [1] &quot;numeric&quot; As funções length(), dim(), nrow() e ncol() são usadas para determinar o comprimento de cada dimensão de um objeto. Observe que atomic vector e factor são estruturas unidimensionais, assim, somente a função length() retornará o número de elementos do objeto, e as demais função retornarão valor nulo NULL. # Array length(meu_array) ## [1] 24 dim(meu_array) ## [1] 4 3 2 nrow(meu_array) ## [1] 4 ncol(meu_array) ## [1] 3 # Matriz length(mat1) ## [1] 36 dim(mat1) ## [1] 6 6 nrow(mat1) ## [1] 6 ncol(mat1) ## [1] 6 # Fator length(trat) ## [1] 9 dim(trat) ## NULL nrow(trat) ## NULL ncol(trat) ## NULL # Atomic vector length(Y) ## [1] 4 dim(Y) ## NULL nrow(Y) ## NULL ncol(Y) ## NULL Todos os objetos apresentados até agora (atomic vector, factor, matrix e arrays) podem ser classificados como estruturas de dados HOMOGÊNEA, pois são compostas por variáveis do mesmo tipo primitivo. Figure 7.4: Estrutura de dados Homogênea é uma coleção de variáveis de mesmo tipo, acessíveis com um único nome e armazenados contiguamente (um após o outro) na memória. Se um conjunto homogêneo de dados é composto por variáveis do mesmo tipo, um conjunto HETEROGÊNEO de dados é composto por elementos que não são do mesmo tipo primitivo. No R temos as listas e os data frames. Figure 7.5: As estruturas heterogêneas constituem um recurso importante para a organização dos dados utilizados devido à possibilidade de tratar um grupo de valores como uma única variável, similar às estruturas homogêneas. 7.4 Listas São estrutras de dados heterogêneas, ou seja, podem ser formadas por vetores de diferentes tipos de dados e de diferentes comprimentos. Em R são frequentemente utilizadas para a passagem de vários argumentos de controle dentro de uma função. Começaremos criando uma lista que consiste em três partes: 4 informações de caracteres em um vetor denominado a, 8 informações numéricas em um vetor denominado b e 3 informações lógicas em um vetor denominado c: a&lt;-c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;) b&lt;-c(1,2,3,4,4,3,2,1) c&lt;-c(T,T,F) Agora vamos utilizar a função list() para agrupar esses objetos. minha_lista &lt;- list(a,b,c) minha_lista ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ## ## [[2]] ## [1] 1 2 3 4 4 3 2 1 ## ## [[3]] ## [1] TRUE TRUE FALSE As funções typeof() e class retornam list e a função length retorna o número de atomic vectors utilizados na criação da lista. Funções como dim(), nrow() e ncol() retornarão NULL. typeof(minha_lista) ## [1] &quot;list&quot; class(minha_lista) ## [1] &quot;list&quot; length(minha_lista) ## [1] 3 Para conseguirmos o número de elementos em cada objeto dentro da lista, poderemos utlizar a função lapply() junto com a função length(). lapply(minha_lista,length) ## [[1]] ## [1] 4 ## ## [[2]] ## [1] 8 ## ## [[3]] ## [1] 3 A função lapply pode ser utilizada juntamente com typeof e/ou class. lapply(minha_lista,typeof) ## [[1]] ## [1] &quot;character&quot; ## ## [[2]] ## [1] &quot;double&quot; ## ## [[3]] ## [1] &quot;logical&quot; 7.5 Data frames Semelhantes às listas, os data frames São estrutras de dados heterogêneas, que podem ser formadas por vetores de diferentes tipos de dados, contudo, todos os vetores têm o mesmo comprimento. São definidos usando a função data.frame(). Um data frame é um objeto com linhas e colunas (parecido com a matriz). As linhas de um data frame contêm diferentes observações do estudo em questão, denominadas registros. As colunas, por sua vez, contêm os valores de diferentes variáveis. Os valores no corpo de uma matriz podem ser apenas números; aqueles em um data.frame também podem ser números, mas também podem ser texto (por exemplo, os nomes dos níveis de fator para variáveis categóricas, como masculino ou feminino em uma variável chamada gênero), eles podem ser datas do calendário (por exemplo, 05/01/21) , ou podem ser variáveis lógicas (TRUE ou FALSE). A etapa mais importante do Data Science é obter o data frame absolutamente correto. A expectativa é que você tenha usado uma planilha eletrônica, como o Excel, para inserir e editar os dados e o que requer alguma prática é aprender exatamente como colocar seus números na planilha. Existem inúmeras maneiras de fazer errado, mas apenas uma maneira de fazer certo. E esta não é a maneira que a maioria das pessoas acha intuitivamente a mais óbvia. O principal é o seguinte: todos os valores da mesma variável devem estar na mesma coluna. Se você fez um experimento com três tratamentos (controle, pré-aquecido e pré-resfriado) e quatro medições por tratamento, pode parecer uma boa ideia criar a planilha como esta: controle pré-aquecido pré-resfriado 6.1 6.3 7.1 5.9 6.2 8.2 5.8 5.8 7.3 5.4 6.3 6.9 No entanto, este não é um data frame, pois os valores da variável resposta aparecem em três colunas diferentes, em vez de todos na mesma coluna. A forma correta de inserir esses dados é ter duas colunas: uma para a variável resposta e outra para os níveis do fator experimental denominada Tratamento (controle, pré-aquecido e pré-resfriado). Aqui estão os mesmos dados, inseridos corretamente como um data.frame: Resposta Tratamento 6.1 controle 5.9 controle 5.8 controle 5.4 controle 6.3 pré-aquecido 6.2 pré-aquecido 5.8 pré-aquecido 6.3 pré-aquecido 7.1 pré-resfriado 8.2 pré-resfriado 7.3 pré-resfriado 6.9 pré-resfriado Para construir esse data frame, primeiramente vamos criar os distintos vetores, numérico e fator. Resposta &lt;- c(6.1,5.9,5.8,5.4,6.3,6.2,5.8,6.3,7.1,8.2,7.3,6.9) Tratamento &lt;- gl(3,4,labels = c(&quot;controle&quot;,&quot;pré-aquecido&quot;,&quot;pré-resfriado&quot;) ) Agrora vamos agrupar esses vetores em um data frame denomidao dados. dados &lt;- data.frame(Resposta, Tratamento) dados ## Resposta Tratamento ## 1 6.1 controle ## 2 5.9 controle ## 3 5.8 controle ## 4 5.4 controle ## 5 6.3 pré-aquecido ## 6 6.2 pré-aquecido ## 7 5.8 pré-aquecido ## 8 6.3 pré-aquecido ## 9 7.1 pré-resfriado ## 10 8.2 pré-resfriado ## 11 7.3 pré-resfriado ## 12 6.9 pré-resfriado Agora vamos extrair algumas informações a respeito desse data frame: Utilize a função length() para retornar o número de vetores (colunas) utilizados para criação do data frame. length(dados) ## [1] 2 A função dim() retornará o número de linhas e o número de colunas do objeto, em analogia, poder-se-ia utilizar as funções nrow() e ncol(). dim(dados) ## [1] 12 2 nrow(dados) ## [1] 12 ncol(dados) ## [1] 2 A função glimpse() do pacote dplyr fornece um resumo rápido a erspeito do data frame, semelhante à função, já estudada str(): Observe que vamos chamar a função glimpse utilizado o :: definindo anteriormente o nome do pacote dplyr na qual ela se encontra, sem a necessidade prévia de carregarmos esse pacote no ambiente de trabalho do R. dplyr::glimpse(dados) ## Rows: 12 ## Columns: 2 ## $ Resposta &lt;dbl&gt; 6.1, 5.9, 5.8, 5.4, 6.3, 6.2, 5.8, 6.3, 7.1, 8.2, 7.3, 6.9 ## $ Tratamento &lt;fct&gt; controle, controle, controle, controle, pré-aquecido, pr... A função names() retorna o nome das colunas (vetores) de um data frame. names(dados) ## [1] &quot;Resposta&quot; &quot;Tratamento&quot; A função names() também pode ser utilizada para atribuir/modificar os nomes das colunas do data frame. names(dados) &lt;- c(&quot;Altura_cm&quot;, &quot;Método&quot;) dados ## Altura_cm Método ## 1 6.1 controle ## 2 5.9 controle ## 3 5.8 controle ## 4 5.4 controle ## 5 6.3 pré-aquecido ## 6 6.2 pré-aquecido ## 7 5.8 pré-aquecido ## 8 6.3 pré-aquecido ## 9 7.1 pré-resfriado ## 10 8.2 pré-resfriado ## 11 7.3 pré-resfriado ## 12 6.9 pré-resfriado O ponto principal sobre como trabalhar efetivamente com data frames é entendermos o uso de subscritos (ou indexação). No R, os subscritos aparecem entre colchetes [ , ]. Lembre-se que um data frame é um objeto bidimensional, compreendendo linhas e colunas. As linhas são referenciadas pelo primeiro subscrito (à esquerda da vírgula) , as colunas pelo segundo subscrito (à direita da vírgula). Portanto, para extrairmos a segunda observação da variável resposta Altura_cm usamos: dados[2,1] ## [1] 5.9 Observe que o retorno foi um atomic vector (vetor). Para extrairmos um subconjuto desse data.frame, composto somente pelos valores de altura referentes ao método pré-aquecido (linhas 5 a 8), vamos utilizar os :, deixando o índice das colunas em branco na indexação. dados[5:8,] ## Altura_cm Método ## 5 6.3 pré-aquecido ## 6 6.2 pré-aquecido ## 7 5.8 pré-aquecido ## 8 6.3 pré-aquecido Observe que o retorno foi um outro data frame. Se o objetivo for apenas os valores numéricos dos pré-aquecidos, temos. dados[5:8,1] ## [1] 6.3 6.2 5.8 6.3 Observe que o retorno foi um atomic vector. Poderíamos extrair todos os valores a partir do operador de acesso de coluna $, chamando primeiramente o objeto e em seguida o nome da coluna. O retorno sempre será um vetor. dados$Altura_cm ## [1] 6.1 5.9 5.8 5.4 6.3 6.2 5.8 6.3 7.1 8.2 7.3 6.9 Observe a diferença no retorno das diferentes formas de acesso a uma coluna. No caso abaixo, vamos acessar a coluna Altura_cm, cujo retorno será um vetor, semelhante ao exemplo anterior. dados[,1] ## [1] 6.1 5.9 5.8 5.4 6.3 6.2 5.8 6.3 7.1 8.2 7.3 6.9 Compare com extração abaixo, nesse caso, temos como retorno um data frame. dados[1] ## Altura_cm ## 1 6.1 ## 2 5.9 ## 3 5.8 ## 4 5.4 ## 5 6.3 ## 6 6.2 ## 7 5.8 ## 8 6.3 ## 9 7.1 ## 10 8.2 ## 11 7.3 ## 12 6.9 Transformações nos dados podem ser realizadas utilizando esse memso operador ($), por exemplo, vamos criar uma nova variável denominada Altura_m a partir da Altura_cm, dividindo cada um de seus valores por 100. dados$Altura_m &lt;- dados$Altura_cm / 100 dados ## Altura_cm Método Altura_m ## 1 6.1 controle 0.061 ## 2 5.9 controle 0.059 ## 3 5.8 controle 0.058 ## 4 5.4 controle 0.054 ## 5 6.3 pré-aquecido 0.063 ## 6 6.2 pré-aquecido 0.062 ## 7 5.8 pré-aquecido 0.058 ## 8 6.3 pré-aquecido 0.063 ## 9 7.1 pré-resfriado 0.071 ## 10 8.2 pré-resfriado 0.082 ## 11 7.3 pré-resfriado 0.073 ## 12 6.9 pré-resfriado 0.069 Agora criaremos a coluna Bloco para identificação dos blocos do experimento. dados$Bloco &lt;- gl(4, 1, 12, labels = c(&quot;I&quot;,&quot;II&quot;,&quot;III&quot;,&quot;IV&quot;)) dados ## Altura_cm Método Altura_m Bloco ## 1 6.1 controle 0.061 I ## 2 5.9 controle 0.059 II ## 3 5.8 controle 0.058 III ## 4 5.4 controle 0.054 IV ## 5 6.3 pré-aquecido 0.063 I ## 6 6.2 pré-aquecido 0.062 II ## 7 5.8 pré-aquecido 0.058 III ## 8 6.3 pré-aquecido 0.063 IV ## 9 7.1 pré-resfriado 0.071 I ## 10 8.2 pré-resfriado 0.082 II ## 11 7.3 pré-resfriado 0.073 III ## 12 6.9 pré-resfriado 0.069 IV Agora podemos modificar a posição das colunas dentro do data frame. Ou seja, vamos “reciclar” o objeto dados guardando esse novo data frame no mesmo identificador. dados &lt;- dados[,c(2,4,1,3)] dados ## Método Bloco Altura_cm Altura_m ## 1 controle I 6.1 0.061 ## 2 controle II 5.9 0.059 ## 3 controle III 5.8 0.058 ## 4 controle IV 5.4 0.054 ## 5 pré-aquecido I 6.3 0.063 ## 6 pré-aquecido II 6.2 0.062 ## 7 pré-aquecido III 5.8 0.058 ## 8 pré-aquecido IV 6.3 0.063 ## 9 pré-resfriado I 7.1 0.071 ## 10 pré-resfriado II 8.2 0.082 ## 11 pré-resfriado III 7.3 0.073 ## 12 pré-resfriado IV 6.9 0.069 Agora devemos criar uma coluna para a identificação (\\(ID\\)) para cada observação. dados$ID &lt;- paste(&quot;obs&quot;, 1:nrow(dados), sep=&quot;_&quot; ) dados ## Método Bloco Altura_cm Altura_m ID ## 1 controle I 6.1 0.061 obs_1 ## 2 controle II 5.9 0.059 obs_2 ## 3 controle III 5.8 0.058 obs_3 ## 4 controle IV 5.4 0.054 obs_4 ## 5 pré-aquecido I 6.3 0.063 obs_5 ## 6 pré-aquecido II 6.2 0.062 obs_6 ## 7 pré-aquecido III 5.8 0.058 obs_7 ## 8 pré-aquecido IV 6.3 0.063 obs_8 ## 9 pré-resfriado I 7.1 0.071 obs_9 ## 10 pré-resfriado II 8.2 0.082 obs_10 ## 11 pré-resfriado III 7.3 0.073 obs_11 ## 12 pré-resfriado IV 6.9 0.069 obs_12 E vamos reordenar o data frame por Altura_cm da menor para a maior (utilize a função order()), em seguida, da maior para a menor nota (argumento decreasing = T). # Classificação do menor para o maior dados[order(dados$Altura_cm),] ## Método Bloco Altura_cm Altura_m ID ## 4 controle IV 5.4 0.054 obs_4 ## 3 controle III 5.8 0.058 obs_3 ## 7 pré-aquecido III 5.8 0.058 obs_7 ## 2 controle II 5.9 0.059 obs_2 ## 1 controle I 6.1 0.061 obs_1 ## 6 pré-aquecido II 6.2 0.062 obs_6 ## 5 pré-aquecido I 6.3 0.063 obs_5 ## 8 pré-aquecido IV 6.3 0.063 obs_8 ## 12 pré-resfriado IV 6.9 0.069 obs_12 ## 9 pré-resfriado I 7.1 0.071 obs_9 ## 11 pré-resfriado III 7.3 0.073 obs_11 ## 10 pré-resfriado II 8.2 0.082 obs_10 # Classificação do maior para o menor dados[order(dados$Altura_cm,decreasing=TRUE),] ## Método Bloco Altura_cm Altura_m ID ## 10 pré-resfriado II 8.2 0.082 obs_10 ## 11 pré-resfriado III 7.3 0.073 obs_11 ## 9 pré-resfriado I 7.1 0.071 obs_9 ## 12 pré-resfriado IV 6.9 0.069 obs_12 ## 5 pré-aquecido I 6.3 0.063 obs_5 ## 8 pré-aquecido IV 6.3 0.063 obs_8 ## 6 pré-aquecido II 6.2 0.062 obs_6 ## 1 controle I 6.1 0.061 obs_1 ## 2 controle II 5.9 0.059 obs_2 ## 3 controle III 5.8 0.058 obs_3 ## 7 pré-aquecido III 5.8 0.058 obs_7 ## 4 controle IV 5.4 0.054 obs_4 "],
["visualização-de-dados-com-o-ggplot2.html", "8 Visualização de dados com o ggplot2 8.1 Criando um gráfico 8.2 Definindo temas 8.3 Controlando elementos do tema 8.4 Mapeamento estéticos 8.5 Facetas 8.6 Objetos geométricos", " 8 Visualização de dados com o ggplot2 O R possui vários sistemas para fazer gráficos, mas o pacote ggplot2 é um dos mais elegantes e versáteis para realizar essa tarefa. O ggplot2 implementa a gramática dos gráficos, um sistema coerente para descrever e construir gráficos. Vamos carregar o tidyverse, que tem o pacote ggplot2 como um de seus elementos centrais. library(tidyverse) Importação dos dados Vamos realizar a importação, via web, do banco de dados geomorfologia.txt. URL &lt;- &quot;https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/geomorfologia.txt&quot; geomorfologia&lt;-read.table(URL, header = TRUE) glimpse(geomorfologia) ## Rows: 106 ## Columns: 22 ## $ SUP &lt;chr&gt; &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;,... ## $ Solo &lt;chr&gt; &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;,... ## $ Amostra &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, ... ## $ X &lt;int&gt; 0, 25, 50, 75, 100, 125, 150, 175, 200, 225, 250, 275, 300,... ## $ AMG &lt;dbl&gt; 0.2, 0.1, 0.7, 0.4, 0.4, 0.4, 1.2, 0.8, 1.1, 1.2, 0.1, 0.2,... ## $ AG &lt;dbl&gt; 3.72, 4.27, 5.00, 3.80, 3.10, 3.80, 3.60, 4.70, 4.50, 5.90,... ## $ AM &lt;dbl&gt; 20.4, 22.6, 22.7, 23.7, 22.3, 23.8, 23.1, 25.8, 25.5, 32.8,... ## $ AF &lt;dbl&gt; 22.9, 23.6, 22.2, 24.4, 24.6, 19.1, 21.7, 21.1, 18.9, 19.8,... ## $ AMF &lt;dbl&gt; 30.0, 28.4, 26.9, 26.7, 26.9, 27.1, 26.5, 24.7, 25.4, 21.7,... ## $ SILTE &lt;dbl&gt; 1.2, 1.2, 1.2, 0.6, 2.1, 2.2, 0.7, 0.2, 2.5, 0.2, 2.5, 2.6,... ## $ ARGILA &lt;dbl&gt; 21.5, 20.4, 21.4, 20.5, 20.7, 23.5, 23.1, 22.7, 22.0, 18.5,... ## $ S_A &lt;dbl&gt; 0.05, 0.05, 0.05, 0.02, 0.10, 0.09, 0.03, 0.01, 0.11, 0.01,... ## $ AF_AG &lt;dbl&gt; 6.16, 5.53, 4.44, 6.42, 7.94, 5.03, 6.03, 4.49, 4.20, 3.36,... ## $ P &lt;dbl&gt; 42, 22, 41, 27, 11, 12, 11, 16, 38, 25, 25, 6, 6, 7, 5, 4, ... ## $ pH &lt;dbl&gt; 4.2, 3.8, 4.8, 4.0, 4.4, 4.0, 4.8, 5.4, 4.4, 5.2, 4.5, 5.1,... ## $ K &lt;dbl&gt; 0.27, 0.11, 0.34, 0.13, 0.11, 0.14, 0.23, 0.28, 0.19, 0.14,... ## $ Ca &lt;dbl&gt; 1.4, 0.4, 2.4, 0.7, 1.4, 0.6, 1.6, 3.3, 1.6, 2.9, 1.3, 1.6,... ## $ Mg &lt;dbl&gt; 0.3, 0.1, 0.4, 0.1, 0.3, 0.1, 0.7, 1.3, 0.5, 1.7, 0.6, 0.8,... ## $ H_Al &lt;dbl&gt; 5.2, 5.8, 4.2, 5.2, 4.2, 5.2, 3.4, 2.5, 5.2, 3.1, 4.2, 2.5,... ## $ SB &lt;dbl&gt; 1.97, 0.61, 3.14, 0.93, 1.81, 0.84, 2.53, 4.88, 2.29, 4.74,... ## $ T &lt;dbl&gt; 7.17, 6.41, 7.34, 6.13, 6.01, 6.04, 5.93, 7.38, 7.49, 7.84,... ## $ V &lt;dbl&gt; 27, 10, 43, 15, 30, 14, 43, 66, 31, 60, 32, 50, 22, 35, 36,... 8.1 Criando um gráfico Vamos criar um gráfico do teor de argila do solo ao longo do transecto estudado. Para isso utilizaremos dois operadores: 1) %&gt;% - chamado PIPE do pacote dplyr o qual pode ser construído com o atalho Ctrl + Shift + M. 2) + - adição, para o controle das camadas gráficas e parâmetros específicos após aplicar a função ggplot(). REGRA: o PIPE sempre opera um DATA FRAME e tem como retorno um novo DATA FRAME e para a ggplot(), o primeiro argumento SEMPRE será um data frame. A forma mais simples para iniciarmos a confecção do gráfico é construírmos cada etapa individual deste, estudando os códigos etapa por etapa. Portanto, mãos a obra. No código abaixo, construiremos somente a tela de plotagem do gráfico. geomorfologia %&gt;% ggplot() Se a nossa inteção é visualizar as alterações dos teores de argila ao longo do transecto nas diferentes superfícies geomórficas, precisamos construir uma gráfico de dispersão (scatter) entre a posição X e o teor de argila do solo. Para isso vamos utilizar a função de estética aes(), dentro da função ggplot(), para definir quais as colunas do objeto geomorfologia serão utilizadas para criação do gráfico. Observe que os eixos agora são desenhados. geomorfologia %&gt;% ggplot(aes(x=X, y =ARGILA)) A geometria de pontos agora deve ser indicada, ou seja, vamos adicionar uma nova camada a esse gráfico. Sempre utilizaremos o operador de adição + para adicioar uma camada de pontos a esse gráfico geom_point(). geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() ## Controlando geometrias Outras geometrias poderiam ser utlizadas, ao invés de pontos, poderíamos pedir uma geometria de linha por exemplo: geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line() Ou poderíamos mesclar as duas geometrias: geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line()+ geom_point() Agora, finalmente, podemos controlar algumas propriedades dentro de cada geometria. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(color=&quot;blue&quot;, # cor da linha lwd= 0.7, # espessura da linha linetype=2)+ # tipo de linha geom_point(shape=21, # tipo do marcador 0-14 são ocas de 15-18 sólidas e de 21-24 possuem borda e preenchimento fill=&quot;green&quot;, # cor do preenchimento do marcador color=&quot;red&quot;, # cor da borda do marcador size=3) # tamanho do marcador OBS: A forma de um ponto (marcador) é controlada pelo argumento shape. Há algumas duplicadas aparentes nesse argumento, que recomendamos qua sejam testadas por exemplo, 0, 15 e 22 são quadrados. A diferença vem da interação das estéticas color e fill. As formas ocas são de 0 a 14 e a cor de sua borda é determinada por color, as formas sólidas são de 15 a 18 e a sua cor de preenchimento é definida por color, já as formas de 21 a 24 têm a cor de sua borda definida por color e a cor de seu preenchimento definida por fill. Veja os exemplos: geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(color=&quot;red&quot;, lwd= 0.7, linetype=1) + geom_point(shape=0, size=5, color = &quot;blue&quot;) geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(color=&quot;red&quot;, lwd= 0.7, linetype=1) + geom_point(shape=15, size=5, color = &quot;blue&quot;) geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(color=&quot;red&quot;, lwd= 0.7, linetype=1) + geom_point(shape=22, size=5, color = &quot;blue&quot;, fill=&quot;green&quot;) Nosso próximo passo será controlar os títulos dos eixos a partir da função labs(). geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(col=&quot;blue&quot;, lwd= 0.7, lty=1)+ geom_point(shape=21, fill=&quot;green&quot;, col=&quot;red&quot;, size=3) + labs(x=&quot;Eixo x (m)&quot;,y=&quot;Teor de argila do solo (%)&quot;, title = &quot;Gráfico de Linha + Pontos&quot;) 8.2 Definindo temas Podemos utilizar diferentes temas, para isso vamos guardar o gráfico anterior em um objeto denominado meu_plot. meu_plot &lt;- geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(col=&quot;blue&quot;, lwd= 0.7, lty=1)+ geom_point(shape=21, fill=&quot;green&quot;, col=&quot;red&quot;, size=3) + labs(x=&quot;Eixo x (m)&quot;,y=&quot;Teor de argila do solo (%)&quot;, title = &quot;Gráfico de Linha + Pontos&quot;) meu_plot Agora podemos aplicar um tema pré-definido ao gráfico a partir da família de função theme_. Compare os diferentes temas diponíveis. meu_plot + theme_minimal() meu_plot + theme_bw() meu_plot + theme_dark() # ... 8.3 Controlando elementos do tema Vários elementos do tema podem ser controlados a partir de funções específicas associadas à função theme(). A família de funções element_ especificam a exibição de como os componentes sem dados do gráfico são desenhados. *element_blank: não desenha nada e não atribui espaço; *element_rect: bordas e fundos; *element_line: linhas; *element_text: texto; *rel() é usado para especificar os tamanhos relativos ao objeto original; *margin() é usado para especificar as margens dos elementos. Por exemplo, vamos duplicar o tamanho de fonte (rel(2)) do título do gráfico já criado meu_plot. meu_plot + theme(plot.title = element_text(size=rel(2))) Vamos modificar o alinhamento do e a cor do título do gráfico já criado meu_plot. meu_plot + theme(plot.title = element_text(hjust = 0.5, color = &quot;red&quot;)) Alterando a área de plotagem. meu_plot + theme(panel.background = element_rect(fill=&quot;lightblue&quot;, color = &quot;red&quot;, linetype = &quot;dashed&quot;)) Agora vamos fazer várias modificações, adicionando linhas de grade na área de plotagem, mudar as cores do texto dos eixos para vermelho, as cores dos títulos dos eixos para verde escuro e alterar a cor do retângulo de plotagem exterior para cinza. meu_plot + theme(panel.grid.major = element_line(color=&quot;gray&quot;, linetype = &quot;dashed&quot;), panel.grid.minor = element_line(color=&quot;gray&quot;, linetype = &quot;dashed&quot;), axis.text = element_text(colour = &quot;red&quot;), axis.title = element_text(colour = &quot;darkgreen&quot;,size=rel(1.2)), plot.background = element_rect(fill=&quot;gray&quot;)) Maiores informações a respeito dos parâmetros de controle dos elementos dos gráficos podem ser encontrados em https://ggplot2.tidyverse.org/reference/theme.html. 8.4 Mapeamento estéticos Vamos voltar ao gráfico de dispersão do teor de argila do solo ao longo do transecto estudado. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() Podemos agora adicionar uma terceira variável a esse gráfico, como tipo de solo (Solo) ou a superfície geomórfica (SUP), e mapeá-la a partir de um estético (aesthetic). Esse estético é uma propriedade visual dos objetos no gráfico. Estéticos incluem coisas como tamanho, forma ou cor dos pontos. Em nosso exemplo inicial Vamos mapear as cores dos pontos para cada superfície geomórfica (SUP). Para mapear a estética cor à variável SUP, devemos associar o nome da estética ao nome da variável dentro de aes(). O ggplot2 atribuirá automaticamente uma cor singular para cada valor singular da variável, um processo conhecido como escalar (scaling). Automaticamente será adicionado uma legenda que explica quais níveis correspondem a quais valores. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, col = SUP) ) + geom_point() No exemplo anterior mapeamos SUP à estética cor, mas poderíamos ter mapeado SUP à estética de tamanho (size) da mesma maneira. Neste caso, o tamanho exato de cada ponto revela a sua superfície. Entretanto, não recomendamos o mapeamento de uma variável por meio do tamanho. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, size = SUP) ) + geom_point() ## Warning: Using size for a discrete variable is not advised. Poderíamos ter mapeado SUP à estética alpha, que controla a transparência e à forma dos pontos controlada pelas estética shape. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, alpha = SUP, shape=SUP) ) + geom_point() 8.5 Facetas As facetas são consideradas uma maneira prática de adicionar mais variáveis categóricas às representações gráficas. Para criar facetas use a função facet_wrap(), cujo primeiro argumento deve ser uma fórmula (definida com ~ e o nome da variável categórica subsequente) e o segundo argumento é o número de linhas do painel gráfico. Compare os painéis abaixo: geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + facet_wrap(~SUP, nrow=1) geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + facet_wrap(~SUP, nrow=3) Outra importante e útil ferramenta é a função facet_grid que permite a incorporação de mais de uma variável na representação, no nosso exemplo, vamos adicionar o tipo de solo Solo. A fórmula conterá dois nomes de variáveis categóricas sepradas pelo ~ geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + facet_grid(SUP ~ Solo) Agora podemos mesclar as visualisações, utilizando o mapeamento estético e as facetas. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=Solo) ) + geom_point() + facet_wrap(~SUP, nrow=1) ou, geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=SUP) ) + geom_point() + facet_wrap(~Solo, nrow=4) + labs(x=&quot;Eixo x (m)&quot;, y= &quot;Teor de argila (%)&quot;, color=&quot;Superfície&quot;) 8.6 Objetos geométricos 8.6.1 Gráfico de Colunas Um geom_ é o objeto geométrico que um gráfico usa para representar os dados. Gráficos de colunas, por exemplo, usam o geom_col(). O preenchimento e as cores das bordas das colunas são controlados pelos argumentos fill e color. Gráfico de coluas, linhas e pontos, plotam os valores brutos. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_col(color=&quot;black&quot;,fill=&quot;aquamarine4&quot;) O gráfico de colunas também pode ser apresentadorotacionado em 90º a partir do uso da funçãocoord_flip(). geomorfologia %&gt;% ggplot( aes(x=X, y=ARGILA) ) + geom_col(color=&quot;black&quot;,fill=&quot;aquamarine4&quot;) + coord_flip() 8.6.2 Gráfico de Barras Diferente do gráfico de colunas, o gráfico de barras possibilita a representação de dados categóricos, vamos supor que devemos contar o número de observações em cada superfície geomórfica. A função geom_bar() conta os pontos em cada categoria de SUP automaticamente. geomorfologia %&gt;% ggplot( aes(x=SUP) ) + geom_bar(color=&quot;black&quot;, fill=&quot;lightblue&quot;) Podemos mapear a superfície geomófica associando SUP à estética fill: geomorfologia %&gt;% ggplot( aes(x=SUP, fill=SUP)) + geom_bar(color=&quot;black&quot;) Se adicionarmos uma segunda variáveis categórica, como o tipo de solo Solo, as barras são automaticamente empilhadas, ondem cada retângulo colorido representa uma combinação de SUP e Solo. geomorfologia %&gt;% ggplot( aes(x=SUP, fill=Solo)) + geom_bar(color=&quot;black&quot;) O empilhamento é realizado automaticamente, caso não queiramos o gráfico empilhado, utilizamos um dos três valores identity, dodge ou fill associados ao argumento position. geomorfologia %&gt;% ggplot( aes(x=SUP, fill=Solo)) + geom_bar(position = &quot;fill&quot;, color=&quot;black&quot;) geomorfologia %&gt;% ggplot( aes(x=SUP, fill=Solo)) + geom_bar(position = &quot;dodge&quot;, color=&quot;black&quot;) 8.6.3 Smoothers Vamos ajustar uma linha suave aos dados de teor de argila ao longo do transecto X a partir da função geom_smooth(). geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + geom_smooth() Dentro de geom_smooth() podemos controlar o tipo da linha e a cor da linha a partir de linetype e color, respectivamente. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + geom_smooth(linetype=2, color=&quot;blue&quot;) Agora vamos aplicar uma linha suave para cada uma das superfícies geomórficas. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=SUP) ) + geom_point() + geom_smooth() Agora em diferentes facetas. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=SUP) ) + geom_point() + geom_smooth() + facet_wrap(~SUP, nrow=1) Para apresentarmos as facetas em diferentes escalas (diferentes valores de X e Y em cada faceta), utilize o argumento scales = \"free\" em facet_wrap(). geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=SUP) ) + geom_point() + geom_smooth() + facet_wrap(~SUP, nrow=1, scales = &quot;free&quot;) 8.6.4 Boxplot Conhecido como gráfico dos 5 números representa um resumos dos valores mínimo, primeiro quartil, mediana, terceiro quartil e máximo. Podem ser construídos para uma variável contínua a partir da geometria geom_boxplot(). Observe que dentro da função ggplot() não é necessário especificar o y, somente é atribuído a x a variável contínua ARGILA. geomorfologia %&gt;% ggplot( aes(x=ARGILA) ) + geom_boxplot() O boxplot é uma caixa que vai do 25º percentil ao 75º percentil da distribuição, uma distância conhecida como a amplitude interquartil (IIQ). No meio da caixa há uma linha que exibe a mediana, isto é, 50º percentil, da distribuição. Essas três linhas lhe dão um sentido da dispersão da distribuição e se ela é ou não simétrica sobre a mediana ou enviesada para um lado. Pontos visuais que exibem observações que caem mais do que 1,5 vez o IIQ de cada limite da caixa. Esses pontos foram da curva são incomuns, entãosão plotados individuaalmente. Uma linha (ou bigode de gato, dai o nome Box and Whiskers) que se estende de cada lado da caixa e vai até o ponto mais distante da distribuição que não seja um outlier. Podemos modificar a orientação do boxplot por meio de aes(y=ARGILA). geomorfologia %&gt;% ggplot( aes(y=ARGILA) ) + geom_boxplot() Outra possibilida é diminuir o tamanho da caixa com coord_cartesian(). geomorfologia %&gt;% ggplot( aes(y=ARGILA) ) + geom_boxplot() + coord_cartesian(xlim=c(-1,1)) Outra alternativa para exibir a distribuição de uma variável contínua é desmembrá-la por uma variável categórica no boxplot. geomorfologia %&gt;% ggplot( aes(y=ARGILA, fill=Solo) ) + geom_boxplot() 8.6.5 Histograma O gráfico histograma é facilmente construído a partir da função geom_histogram(). Semelhante ao geom_boxplot() dentro da função ggplot() é atribuído a x a variável contínua ARGILA. geomorfologia %&gt;% ggplot(aes(x=ARGILA)) + geom_histogram() Observe que o histograma foi construído com a frequencia absoluta de cada classe, ou seja, o número de observações (contagem) dentro de cada classe de teor de argila construída automaticamentem pela função. Se ao invés da contagem, quiséssemos a densidade de frenquência, deveremos utilizar y=..density.. dentro de aes(). geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram() Podemos estabelecer a amplitude dos intervalos em um histograma com o argumento bidwidth, que é medido nas unidades da variável x. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram(binwidth = 1) Ou você pode especificar o número de classes a partir do argumento bins, que por default é igual a 30. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram(bins = 15) Vamos alterar as cores das bordas e do preeenchimento das colunas do histograma. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram(bins = 15, color=&quot;black&quot;,fill=&quot;white&quot;) Podemos associar a curva suave de densidade no hitograma, a partir da função geom_density() e controlar a transparência e seu preenchimento a partir dos argumentos alpha e fill, respectivamente. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram(bins = 15,color=&quot;black&quot;,fill=&quot;white&quot;)+ geom_density(alpha=.10, fill=&quot;red&quot;) Finalmente, podemos construir um histograma da variável ARGILA para cada superfície geomórfica. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density.., color=SUP, fill=SUP)) + geom_histogram(bins = 15, color=&quot;black&quot;,fill=&quot;white&quot;)+ geom_density(alpha=.2)+ facet_wrap(~SUP, scales=&quot;free&quot;)+ labs(x=&quot;Teor de argila do solo (%)&quot;, y = &quot;Densidade&quot;, fill=&quot;Superfície&quot;, color=&quot;Superfície&quot;) + theme_minimal() "],
["manipulação-de-dados-com-o-dplyr.html", "9 Manipulação de dados com o dplyr 9.1 Principais funções (verbos) do dplyr. 9.2 Regras para manipulação: 9.3 filter() 9.4 arrange() 9.5 select() 9.6 mutate() 9.7 Resumos Agrupados com summarize()", " 9 Manipulação de dados com o dplyr A visualização de dados é uma ferramenta importante para a geração de insights, mas é raro que tenhamos os dados exatamente na forma necessário para essa tarefa. Muitas vezes precisamos realizar recortes no banco de dados, selecionar certas observações, criar novas variáveis, transformá-la, renomeá-las, reordenar observações entre outras manipulações. Para a manipulação dos nossos dados, vamos utilizar o pacote dplyr que, unido ao pacote ggplot2, é um poderoso recurso para exploração, transformação e visualização de dados. Ambos os pacotes fazem parte do tidyverse, que, como já dito, é um pacote de pacotes. 9.1 Principais funções (verbos) do dplyr. filter(): seleciona/filtra por linhas (observações) a base de dados. arrange(): ordena a base de dados de acordo com alguma coluna (variável). select(): seleciona colunas (variáveis). mutate(): modifica/transforma/cria variáveis (colunas). summarise(): resume/agrega, variáveis (colunas) de uma base de dados. 9.2 Regras para manipulação: 1- O primeiro argumento sempre será um data frame. 2- Demais argumentos, descrevem como deve ser a manipulação. 3- A resposta (retorno) sempre será um data frame. 4- Manipulação é realizada com o operador “PIPE” (%&gt;%) - CTRL + SHIFT + M. Importação dos dados Vamos realizar a importação, via web, do banco de dados geomorfologia.txt. library(tidyverse) URL &lt;- &quot;https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/geomorfologia.txt&quot; geomorfologia&lt;-read.table(URL,header = TRUE) glimpse(geomorfologia) ## Rows: 106 ## Columns: 22 ## $ SUP &lt;chr&gt; &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;,... ## $ Solo &lt;chr&gt; &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;,... ## $ Amostra &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, ... ## $ X &lt;int&gt; 0, 25, 50, 75, 100, 125, 150, 175, 200, 225, 250, 275, 300,... ## $ AMG &lt;dbl&gt; 0.2, 0.1, 0.7, 0.4, 0.4, 0.4, 1.2, 0.8, 1.1, 1.2, 0.1, 0.2,... ## $ AG &lt;dbl&gt; 3.72, 4.27, 5.00, 3.80, 3.10, 3.80, 3.60, 4.70, 4.50, 5.90,... ## $ AM &lt;dbl&gt; 20.4, 22.6, 22.7, 23.7, 22.3, 23.8, 23.1, 25.8, 25.5, 32.8,... ## $ AF &lt;dbl&gt; 22.9, 23.6, 22.2, 24.4, 24.6, 19.1, 21.7, 21.1, 18.9, 19.8,... ## $ AMF &lt;dbl&gt; 30.0, 28.4, 26.9, 26.7, 26.9, 27.1, 26.5, 24.7, 25.4, 21.7,... ## $ SILTE &lt;dbl&gt; 1.2, 1.2, 1.2, 0.6, 2.1, 2.2, 0.7, 0.2, 2.5, 0.2, 2.5, 2.6,... ## $ ARGILA &lt;dbl&gt; 21.5, 20.4, 21.4, 20.5, 20.7, 23.5, 23.1, 22.7, 22.0, 18.5,... ## $ S_A &lt;dbl&gt; 0.05, 0.05, 0.05, 0.02, 0.10, 0.09, 0.03, 0.01, 0.11, 0.01,... ## $ AF_AG &lt;dbl&gt; 6.16, 5.53, 4.44, 6.42, 7.94, 5.03, 6.03, 4.49, 4.20, 3.36,... ## $ P &lt;dbl&gt; 42, 22, 41, 27, 11, 12, 11, 16, 38, 25, 25, 6, 6, 7, 5, 4, ... ## $ pH &lt;dbl&gt; 4.2, 3.8, 4.8, 4.0, 4.4, 4.0, 4.8, 5.4, 4.4, 5.2, 4.5, 5.1,... ## $ K &lt;dbl&gt; 0.27, 0.11, 0.34, 0.13, 0.11, 0.14, 0.23, 0.28, 0.19, 0.14,... ## $ Ca &lt;dbl&gt; 1.4, 0.4, 2.4, 0.7, 1.4, 0.6, 1.6, 3.3, 1.6, 2.9, 1.3, 1.6,... ## $ Mg &lt;dbl&gt; 0.3, 0.1, 0.4, 0.1, 0.3, 0.1, 0.7, 1.3, 0.5, 1.7, 0.6, 0.8,... ## $ H_Al &lt;dbl&gt; 5.2, 5.8, 4.2, 5.2, 4.2, 5.2, 3.4, 2.5, 5.2, 3.1, 4.2, 2.5,... ## $ SB &lt;dbl&gt; 1.97, 0.61, 3.14, 0.93, 1.81, 0.84, 2.53, 4.88, 2.29, 4.74,... ## $ T &lt;dbl&gt; 7.17, 6.41, 7.34, 6.13, 6.01, 6.04, 5.93, 7.38, 7.49, 7.84,... ## $ V &lt;dbl&gt; 27, 10, 43, 15, 30, 14, 43, 66, 31, 60, 32, 50, 22, 35, 36,... As práticas abaixo serão realizadas sem o armazenamento dos resultados em novos objetos, assim ao final de cada operação será utilizado a função View() para gerar a visualização do data frame resultante (.) em uma nova aba do RStudio. 9.3 filter() O filter() permite que você crie um subconjuto de observações com base em seus valores. Por exemplo, vamos selecionar somente as observações linhas para superfície geomórfica II. Para isso, dentro da função filter() faremos uma operação relacional, perguntando quais valores de SUP são iguais a II. geomorfologia %&gt;% filter(SUP == &quot;II&quot;) %&gt;% View() Quando executamos essa linha de código o dplyr realiza a operação de filtragem e retorna um novo data frame. As entradas não são modificadas, então, para salvar o resultado em um novo objeto, será necessário a operação de atribuição (&lt;-) a um novo objeto, por exemplo dado_auxiliar: dado_auxiliar &lt;- geomorfologia %&gt;% filter(SUP == &quot;II&quot;) glimpse(dado_auxiliar) ## Rows: 62 ## Columns: 22 ## $ SUP &lt;chr&gt; &quot;II&quot;, &quot;II&quot;, &quot;II&quot;, &quot;II&quot;, &quot;II&quot;, &quot;II&quot;, &quot;II&quot;, &quot;II&quot;, &quot;II&quot;, &quot;II&quot;,... ## $ Solo &lt;chr&gt; &quot;LVp&quot;, &quot;LVp&quot;, &quot;LVp&quot;, &quot;LVp&quot;, &quot;LVp&quot;, &quot;LVp&quot;, &quot;LVp&quot;, &quot;LVp&quot;, &quot;LV... ## $ Amostra &lt;int&gt; 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,... ## $ X &lt;int&gt; 425, 450, 475, 500, 525, 550, 575, 600, 625, 650, 675, 700,... ## $ AMG &lt;dbl&gt; 0.2, 0.3, 0.1, 0.2, 0.2, 0.2, 0.2, 0.2, 0.3, 0.5, 0.4, 0.2,... ## $ AG &lt;dbl&gt; 3.64, 3.43, 3.23, 2.83, 3.85, 3.64, 3.64, 4.45, 4.24, 6.14,... ## $ AM &lt;dbl&gt; 27.5, 24.6, 23.7, 19.2, 16.6, 19.0, 19.0, 23.3, 20.6, 30.3,... ## $ AF &lt;dbl&gt; 24.5, 34.2, 25.7, 27.0, 15.9, 18.4, 18.4, 23.3, 21.9, 20.5,... ## $ AMF &lt;dbl&gt; 20.4, 12.6, 24.7, 28.0, 35.3, 32.1, 32.1, 26.4, 27.3, 20.2,... ## $ SILTE &lt;dbl&gt; 1.8, 4.0, 2.1, 4.2, 2.7, 1.0, 1.0, 1.0, 1.2, 1.6, 1.8, 0.6,... ## $ ARGILA &lt;dbl&gt; 22.0, 21.0, 20.5, 18.5, 25.5, 26.6, 26.6, 21.4, 24.4, 20.7,... ## $ S_A &lt;dbl&gt; 0.08, 0.19, 0.10, 0.23, 0.11, 0.04, 0.04, 0.05, 0.05, 0.08,... ## $ AF_AG &lt;dbl&gt; 6.73, 9.97, 7.96, 9.54, 4.13, 5.05, 5.05, 5.24, 5.17, 3.34,... ## $ P &lt;dbl&gt; 3, 2, 3, 3, 2, 2, 2, 3, 4, 4, 6, 2, 3, 2, 14, 106, 107, 83,... ## $ pH &lt;dbl&gt; 4.0, 3.9, 3.9, 3.8, 3.8, 3.8, 3.8, 4.0, 3.8, 3.9, 4.0, 3.8,... ## $ K &lt;dbl&gt; 0.05, 0.01, 0.04, 0.01, 0.02, 0.01, 0.01, 0.16, 0.04, 0.08,... ## $ Ca &lt;dbl&gt; 0.6, 0.3, 0.4, 0.2, 0.2, 0.2, 0.2, 0.5, 0.2, 0.4, 0.6, 0.4,... ## $ Mg &lt;dbl&gt; 0.2, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1,... ## $ H_Al &lt;dbl&gt; 5.2, 5.2, 5.8, 6.4, 6.4, 6.4, 5.8, 4.2, 5.2, 5.2, 5.8, 5.8,... ## $ SB &lt;dbl&gt; 0.85, 0.41, 0.54, 0.31, 0.32, 0.31, 0.31, 0.76, 0.34, 0.58,... ## $ T &lt;dbl&gt; 6.05, 5.61, 6.34, 6.71, 6.72, 6.71, 6.11, 4.96, 5.54, 5.78,... ## $ V &lt;dbl&gt; 14, 7, 9, 5, 5, 5, 5, 15, 6, 10, 12, 8, 12, 22, 54, 38, 46,... Agora vamos selecionar as observações com teor de argila maior do que \\(10\\%\\), provenientes da superfície III. Para realizarmos essa operação, serão necessárias duas operações relacionais, uma com a coluna ARGILA e outra com a coluna SUP, tais operações serão realizadas dentro de filter() separadas por uma vírgula. geomorfologia %&gt;% filter(ARGILA &gt; 10, SUP == &quot;III&quot;) %&gt;% View() Selecione todas as observações que não sejam Regossolo, ou seja, todas os registros cujo tipo de solo seja diferente de R. geomorfologia %&gt;% filter(Solo != &quot;R&quot;) %&gt;% View() ou geomorfologia %&gt;% filter(!(Solo == &quot;R&quot;)) %&gt;% View() Anteriormente utilizamos a geometria geom_bar() para contar o número de pontos amostrais em uma categoria. Para observarmos a tabela com a contagem poderíamos utilizar as função group_by() para agruparmos as categorias da variável SUP e, posteriormente, a função count() para realizar o processo de contagem das observações em cada grupo, gerando uma tabela com as colunas SUP para as categorias de superfície e n para a contagem. geomorfologia %&gt;% group_by(SUP) %&gt;% count() %&gt;% View() Pronto, agora podemos associar o ggplot() a essa filtragem: geomorfologia %&gt;% group_by(SUP) %&gt;% count() %&gt;% ggplot(aes(x=SUP, y=n)) + geom_col(color=&quot;black&quot;,fill=&quot;lightblue&quot;) Agora vamos selecionar somente os registros referentes aos Latossolos, ou seja, todos aqueles que tenham nomes iguais a LV ou LVp. Para essa manipulação, podemos utilizar o operador lógico de disjunção OU |. geomorfologia %&gt;% filter(Solo == &quot;LV&quot; | Solo == &quot;LVp&quot;) %&gt;% View() Um atalho útil para a solução desse problema é o operador x %in% y. Isso selecionará toda linha em que x seja um dos valores em y, então, vamos reescrever o código acima de uma manira mais elegante. geomorfologia %&gt;% filter(Solo %in% c(&quot;LV&quot;,&quot;LVp&quot;)) %&gt;% View() 9.3.1 Valores Faltantes Um recurso importante do R que pode complicar as comparações e, consequentemente as operações de filtragem, são os valores faltantes ou NAs (not availables). NA representa um valor desconhecido, então valores faltantes se propagam nas operações, são contagiosos, ou seja, quase toda operação envolvendo um valor desconhecido terá como resultado um valor desconhecido. NA &gt; 5 ## [1] NA 10 == NA ## [1] NA NA + 10 ## [1] NA NA / 2 ## [1] NA NA == NA ## [1] NA Seja x a idade de Maria. Não sabemos a idade de Maria: x &lt;- NA Seja y a idade de João. Não sabemos a idade de João: y &lt;- NA Maria e João têm a mesma idade? x == y ## [1] NA # Não sabemos. Se quisermos determinar se há um valor faltante, usamos a função is.na(). is.na(x) ## [1] TRUE is.na(y) ## [1] TRUE A função filter() somente inclui linhas onde a condição é TRUE, ou seja, ela exclui valores FALSE e NA automaticamente. Vamos criar um exemplo rápido referente a nota de 7 alunos na primeira prova da disciplina de estatística da FCAV do curso de Agronomia. df &lt;- tibble(nome = c(&quot;Ana&quot;,&quot;Beatriz&quot;,&quot;Douglas&quot;,&quot;Luis&quot;,&quot;Marcela&quot;,&quot;Paulo&quot;,&quot;Renata&quot;), P1 = c(8,NA,6,3,NA,6,3), P2=c(9,7,4,2,NA,NA,4), Psub=c(NA,8,7,9,NA,5,6)) df ## # A tibble: 7 x 4 ## nome P1 P2 Psub ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ana 8 9 NA ## 2 Beatriz NA 7 8 ## 3 Douglas 6 4 7 ## 4 Luis 3 2 9 ## 5 Marcela NA NA NA ## 6 Paulo 6 NA 5 ## 7 Renata 3 4 6 Se quisermos realizar a filtragem para todos os valores de P1 maiores que 4: df %&gt;% filter(P1 &gt; 4) ## # A tibble: 3 x 4 ## nome P1 P2 Psub ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ana 8 9 NA ## 2 Douglas 6 4 7 ## 3 Paulo 6 NA 5 Se quisermos preservar o NA, devemos pedir explicitamente, caso contrário eles serão excluídos da filtragem. df %&gt;% filter(P1 &gt; 4 | is.na(P1)) ## # A tibble: 5 x 4 ## nome P1 P2 Psub ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ana 8 9 NA ## 2 Beatriz NA 7 8 ## 3 Douglas 6 4 7 ## 4 Marcela NA NA NA ## 5 Paulo 6 NA 5 Vamos selecionar os alunos que fizeram, pelo menos, uma prova. df %&gt;% filter(!is.na(P1) | !is.na(P2) | !is.na(Psub)) ## # A tibble: 6 x 4 ## nome P1 P2 Psub ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ana 8 9 NA ## 2 Beatriz NA 7 8 ## 3 Douglas 6 4 7 ## 4 Luis 3 2 9 ## 5 Paulo 6 NA 5 ## 6 Renata 3 4 6 Agora vamos selecionar os alunos que fizeram as 3 provas. df %&gt;% filter(!is.na(P1), !is.na(P2), !is.na(Psub)) ## # A tibble: 3 x 4 ## nome P1 P2 Psub ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Douglas 6 4 7 ## 2 Luis 3 2 9 ## 3 Renata 3 4 6 9.3.2 Strings e Regex A função str_detect() pertence ao pacote stringr e tem a finalidade de detectar a presença ou a ausência de um padrão de caracteres dentro de uma string (cadeia de caracteres). O pacote stringr faz parte do pacote tidyverse, cuja sintaxe é o Regex (do inglês Regular Expressions), ou seja, são expressões regulares para descrever os padrões dentro da string. Uma breve explicação se faz necessária para aplicações posteriores. Vamos criar duas strings: string1 &lt;- &quot;Isso é uma string&quot; string2 &lt;- &#39;Se você quiser adicionar &quot;aspas duplas&quot; dentro da string, utilize aspas simples&#39; string1 ## [1] &quot;Isso é uma string&quot; string2 ## [1] &quot;Se você quiser adicionar \\&quot;aspas duplas\\&quot; dentro da string, utilize aspas simples&quot; A representação impressa de uma string mostra as barras transversas \\, já o conteúdo bruto da string pode ser apresentado por writeLines(). writeLines(string2) ## Se você quiser adicionar &quot;aspas duplas&quot; dentro da string, utilize aspas simples Observe mais esse exemplo. * \\\" aspas duplas * \\\\ caractere de barra transversa * \\n nova linha * \\t tabulação * \\u00b5 caracteres que não pertencem ao inglês. string3 &lt;- c(&quot;\\&quot;&quot;, &quot;\\n&quot;, &quot;\\\\&quot;, &quot;A\\tB&quot;, &quot;\\n&quot;, &quot;\\u00b5&quot;) string3 ## [1] &quot;\\&quot;&quot; &quot;\\n&quot; &quot;\\\\&quot; &quot;A\\tB&quot; &quot;\\n&quot; &quot;µ&quot; writeLines(string3) ## &quot; ## ## ## \\ ## A B ## ## ## µ O pacote básico do R contém muitas funções para trabalhar com strings, mas vamos evitá-las porque podem ser inconsistentes, o que as torna difíceis de lembrar. Já o pacote stringr é de mais simples utilização, pois têm nomes intuitivos, todos começam com str_. Por exemplo, str_length() informa o número de caracteres em uma string: meu_texto &lt;- c(&#39;a&#39;,&#39;R para data science&#39;, NA, &#39;UNESP-FCAV&#39;) str_length(meu_texto) ## [1] 1 19 NA 10 A combinação de strings pode ser feita com o str_c(), utilizando o argumento sep para controlar o separador entre as strings. str_c(&quot;objeto&quot;, 1:5, sep=&quot;_&quot;) ## [1] &quot;objeto_1&quot; &quot;objeto_2&quot; &quot;objeto_3&quot; &quot;objeto_4&quot; &quot;objeto_5&quot; OBS Poderíamos ter o mesmo efeito com a função paste() do pacote base. paste(&quot;objeto&quot;, 1:5, sep=&quot;_&quot;) ## [1] &quot;objeto_1&quot; &quot;objeto_2&quot; &quot;objeto_3&quot; &quot;objeto_4&quot; &quot;objeto_5&quot; Contudo, observe a forma com a qual as funções operam valores faltantes NA. paste(&quot;objeto&quot;, c(1,NA,3), sep=&quot;_&quot;) ## [1] &quot;objeto_1&quot; &quot;objeto_NA&quot; &quot;objeto_3&quot; str_c(&quot;objeto&quot;, c(1,NA,3), sep=&quot;_&quot;) ## [1] &quot;objeto_1&quot; NA &quot;objeto_3&quot; str_c(&quot;objeto&quot;, str_replace_na(c(1,NA,3)), sep=&quot;_&quot;) ## [1] &quot;objeto_1&quot; &quot;objeto_NA&quot; &quot;objeto_3&quot; Como a maioria das outras funções em R, os valores ausentes se propagam nas operações. Se você quiser que eles sejam impressos como NA, use str_replace_na(): str_c(&quot;---&quot;, meu_texto, &quot;---&quot;) ## [1] &quot;---a---&quot; &quot;---R para data science---&quot; ## [3] NA &quot;---UNESP-FCAV---&quot; str_c(&quot;---&quot;, str_replace_na(meu_texto), &quot;---&quot;) ## [1] &quot;---a---&quot; &quot;---R para data science---&quot; ## [3] &quot;---NA---&quot; &quot;---UNESP-FCAV---&quot; Para colapsar um vetor de strings em uma única string, use o argumento colappse na função str_c(): y &lt;- c(&quot;A&quot;,&quot;mais&quot;,&quot;bonita&quot;) y ## [1] &quot;A&quot; &quot;mais&quot; &quot;bonita&quot; str_c(y, collapse = &quot; &quot; ) ## [1] &quot;A mais bonita&quot; str_c(meu_texto, collapse = &quot;, &quot;) # propagação do NA ## [1] NA str_c(str_replace_na(meu_texto), collapse = &quot;, &quot;) ## [1] &quot;a, R para data science, NA, UNESP-FCAV&quot; Podemos extrair partes de uma string usando str_sub(), que leva os argumentos inicial e final que fornecem a posição (inclusiva) da substring. No exemplo abaixo, vamos extrair do primeiro ao quarto caracter de cada string do objeto x. x &lt;- c (&quot;testemunha&quot;,&quot;escarificador&quot;,&quot;arado de disco&quot;,&quot;grade aradora&quot;,&quot;subsolador&quot;) str_sub(x,1,4) ## [1] &quot;test&quot; &quot;esca&quot; &quot;arad&quot; &quot;grad&quot; &quot;subs&quot; Números negativos contam de trás para frente para a realizar a extração. str_sub(x,-4,-1) ## [1] &quot;unha&quot; &quot;ador&quot; &quot;isco&quot; &quot;dora&quot; &quot;ador&quot; Podemos utilizar essa função para alterar uma string, por exemplo, passar as primeira letras para maiúsculas str_sub(x,1,1) &lt;- str_to_upper(str_sub(x,1,1)) x ## [1] &quot;Testemunha&quot; &quot;Escarificador&quot; &quot;Arado de disco&quot; &quot;Grade aradora&quot; ## [5] &quot;Subsolador&quot; Ou podemos passar todas para maiúsculas. str_sub(x,1,str_length(x)) &lt;- str_to_upper(str_sub(x,1,str_length(x))) x ## [1] &quot;TESTEMUNHA&quot; &quot;ESCARIFICADOR&quot; &quot;ARADO DE DISCO&quot; &quot;GRADE ARADORA&quot; ## [5] &quot;SUBSOLADOR&quot; Ou podemos passar todas para minúsculas, novamente… str_sub(x,1,str_length(x)) &lt;- str_to_lower(str_sub(x,1,str_length(x))) x ## [1] &quot;testemunha&quot; &quot;escarificador&quot; &quot;arado de disco&quot; &quot;grade aradora&quot; ## [5] &quot;subsolador&quot; Podemos buscar combinações simples, para facilitar a verificação, vamos utilizar str_view(). str_view(x, &quot;ad&quot;) Podemos utilizar o ponto . para encontrar a combinação com qualquer caractere (exceto no início ou no final da string). str_view(x, &quot;.a.&quot;) Se estivermos procurando o caractere ponto ., vamos utilizar \\\\.. meu_texto_2 &lt;- c(&quot;abc&quot;, &quot;a*b&quot;, &quot;a b&quot; ,&quot;a.c&quot;) str_view(meu_texto_2, &quot;\\\\.&quot;) Por default, as expressões regulares corresponderão a qualquer parte de uma string. Muitas vezes, é útil ancorar a expressão regular de forma que corresponda desde o início ou ao final da string. Assim, podemos utilizar as âncoras: *^ para combinar com o início da string. *$ para combinar com o final da string. str_view(x, &quot;^a&quot;) str_view(x, &quot;r$&quot;) Para forçar uma expressão regular a corresponder apenas a uma string completa, ancore-a com ^ e $: z&lt;-c(&quot;Arado&quot;,&quot;Arado de disco&quot;,&quot;Arado de aiveca&quot;, &quot;Grade aradora&quot;) str_view(z,&quot;Arado&quot;) str_view(z,&quot;^Arado$&quot;) Voltando à manipulação dos dados de geomorfologia, agora podemos filtrar todos os Argissolos utilizando o regex, ou seja, podemos selecionar todos aqueles solos que començam com a letra P. geomorfologia %&gt;% filter(str_detect(Solo,&quot;^P&quot;)) %&gt;% View() Selecione os registros cujo solo é “PV4.” geomorfologia %&gt;% filter(str_detect(Solo,&quot;PV4&quot;)) %&gt;% View() geomorfologia %&gt;% filter(str_detect(Solo,&quot;4$&quot;)) %&gt;% View() Podemos criar nossas próprias classes de personagens de busca usando [ ]: [abc]: corresponde a, b ou c. [a-z]: corresponde a todos os caracteres entre a e z. [^abc]: corresponde a qualquer coisa, exceto a, b ou c. [\\^\\-]: corresponde a ^ ou -. Por exemplo, retirando, novamente, o Regossolo. geomorfologia %&gt;% filter(str_detect(Solo,&quot;[^R]&quot;)) %&gt;% View() [:space:]: caracteres de espaço (basicamente equivalente a \\s). [:blank:]: espaço e tabulação. Selecione os registros que terminam com um número. geomorfologia %&gt;% filter(str_detect(Solo,&quot;[:digit:]$&quot;)) %&gt;% View() Selecione todos aqueles que não tenham dígitos nos nomes. geomorfologia %&gt;% filter(!str_detect(Solo,&quot;[:digit:]&quot;)) %&gt;% View() OBS: Todos eles vão dentro de [ ] para classes de caracteres, ou seja, [[:dígito:]AX] corresponde a todos os dígitos, a letra A e a letra X. Selecione todos Regossolos ou Latossolos. geomorfologia %&gt;% filter(str_detect(Solo,&quot;R|LV&quot;)) %&gt;% View() Selecione todos Regossolos ou Latossolos LV, excluindo o LVp. geomorfologia %&gt;% filter(str_detect(Solo,&quot;R|^LV$&quot;)) %&gt;% View() Figure 9.1: Um exemplo patológico devido à complexidade de endereços de e-mail. 9.4 arrange() A funçao arrange() funciona de maneira similar a filter(), mas, ao invés de selecionar linhas, ela muda a ordem delas. Ela recebe um data frame e um conjunto de nomes de colunas pelos quais ordenar. Se fornecermos mais de um nome de coluna, cada coluna adicional será usada para desempate nos valores das colunas anteriores. Vamos classificar os registros por ordem crescente de teor de argila. geomorfologia %&gt;% arrange(ARGILA) %&gt;% View() Classifique os registros por ordem decrescente de teor de acidez \\(H+Al\\). Para isso vamos utilizar a função desc() que reordena a coluna em ordem descendente. geomorfologia %&gt;% arrange(desc(H_Al)) %&gt;% View() Classifique os registros por ordem alfabéticas de solos e utilize como crotério de desempate o teor de fósforo disponível no solo em ordem decrescente. geomorfologia %&gt;% arrange(Solo, desc(P)) %&gt;% View() Valores faltantes são sempre colocados no final, veja o exemplo abaixo utilizando as notas de alunos anterioremente criadas. df %&gt;% arrange(desc(Psub)) ## # A tibble: 7 x 4 ## nome P1 P2 Psub ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Luis 3 2 9 ## 2 Beatriz NA 7 8 ## 3 Douglas 6 4 7 ## 4 Renata 3 4 6 ## 5 Paulo 6 NA 5 ## 6 Ana 8 9 NA ## 7 Marcela NA NA NA 9.5 select() Não é incomum obter conjuntos de dados com centenas ou até milhares de variáveis. Neste caso, o primeiro desafio frequentemente é limitar-se às variávies em que você realmente está interessado. A função select() permite que você foque em um subconjunto útil usando operações baseadas em nomes de variáveis. Seleciona colunas de uma tabela e pode ser utilizado com as funções: * starts_with(&quot;abc&quot;): seleciona nomes que começam com &quot;abc&quot; * ends_with(&quot;xyz&quot;): seleciona nomes que terminam com &quot;xyz&quot; * contains(&quot;ijk&quot;): seleciona nomes que contêm &quot;ijk&quot; * matches(&quot;(.)\\\\1&quot;): seleciona nomes usando Expressões Regulares * num_range(&quot;x&quot;, 1:3): seleciona x1, x2 e x3 Selecione as colunas SUP, Solo e ARGILA. geomorfologia %&gt;% select(SUP, Solo, ARGILA) %&gt;% View() Selecione as colunas que comecem com a letra “A.” geomorfologia %&gt;% select(starts_with(&quot;A&quot;)) %&gt;% View() Selecione as colunas que NÃO comecem com a letra “A.” geomorfologia %&gt;% select(-starts_with(&quot;A&quot;)) %&gt;% View() 9.6 mutate() Vamos voltar ao exemplo das notas dos alunos, que estão armazenadas no data frame df. df ## # A tibble: 7 x 4 ## nome P1 P2 Psub ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ana 8 9 NA ## 2 Beatriz NA 7 8 ## 3 Douglas 6 4 7 ## 4 Luis 3 2 9 ## 5 Marcela NA NA NA ## 6 Paulo 6 NA 5 ## 7 Renata 3 4 6 Devemos agora calcular a média final do aluno, seguindo o critério: \\[ MF = \\frac{P1+P2}{2} \\] Se o aluno fez a prova substitutiva (Psub) ela deve substituir a prova faltante, ou a menor das notas das provas. df %&gt;% mutate( SOMA = if_else(is.na(Psub),P1+P2, if_else(is.na(P1),P2+Psub, if_else(is.na(P2),P1+Psub, if_else(P1&lt;P2,P2+Psub,P1+Psub)))), MF=SOMA/2 ) ## # A tibble: 7 x 6 ## nome P1 P2 Psub SOMA MF ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ana 8 9 NA 17 8.5 ## 2 Beatriz NA 7 8 15 7.5 ## 3 Douglas 6 4 7 13 6.5 ## 4 Luis 3 2 9 12 6 ## 5 Marcela NA NA NA NA NA ## 6 Paulo 6 NA 5 11 5.5 ## 7 Renata 3 4 6 10 5 Vamos criar duas novas variáveis, primeiro vamos calcular a soma dos teores de ARGILA + SILTE e, em seguida, passar o teor de fósforo para a escala logarítmica. geomorfologia %&gt;% mutate( ARG_SILT = ARGILA + SILTE, log_P = log10(P)) %&gt;% View() Classifique a Textura do solo. Figure 9.2: A figura 1 apresenta os intervalos de argila e a respectiva classificação do solo. . FONTE (https://www.pedologiafacil.com.br/textura.php) geomorfologia %&gt;% mutate( TEXTURA = case_when( ARGILA &lt; 15 ~ &quot;Arenosa&quot;, ARGILA &lt;= 35 ~ &quot;Media&quot;, ARGILA &lt;= 60 ~ &quot;Argilosa&quot;, ARGILA &gt; 60 ~ &quot;Muito argilosa&quot;, TRUE ~ &quot;Sem classificação&quot;) ) 9.7 Resumos Agrupados com summarize() A função summarize() reduz um data frame a uma única linha: geomorfologia %&gt;% summarize(media_ARGILA = mean(ARGILA, na.rm = TRUE)) ## media_ARGILA ## 1 14.60189 Essa função é extremamente útil quando combinada à função group_by(). Isso muda a unidade da análise de todo o conjunto de dados para os grupos de individuais. Então, ao usarmos os verbos do dplyr em um data frame agrupado, eles são automaticamente aplicados “por grupo.” Por exemplo, vamos aplicar o mesmo código anterior ao data frame agrupado por superfície geomórfica, obteremos: geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(media_ARGILA = mean(ARGILA, na.rm = TRUE)) ## # A tibble: 3 x 2 ## SUP media_ARGILA ## &lt;chr&gt; &lt;dbl&gt; ## 1 I 21.1 ## 2 II 14.8 ## 3 III 10.1 9.7.1 Valores faltantes O argumento na.rm = TRUE é utilizado para remoção dos valores faltantes da variáviel. Isso porque as funções de agregação obedecem à regra usual de NAs, ou seja, qualquer valor faltando na entrada, a saída será um valor faltante. Assim o uso desse argumento é essencial. 9.7.2 Counts Sempre que fizer agregação, sugerimos que inclua uma contagem n() ou uma contagem de valores não faltantes (sum(!is.na(x))). Deste modo podemos verificar que não estamos tirando conclusões com base em quantidades muito pequenas de dados. Por exemplo, vamos pedir a média da variável AMG (areia muito grossa) para cada tipo de solo identificado no levantamento em função do número de observações (n). Para isso vamos unir as funções group_by(), summarize() e ggplot(). geomorfologia %&gt;% group_by(Solo) %&gt;% summarize( media_AMG = mean(AMG, na.rm=TRUE), n = n()) %&gt;% ggplot(aes(x=n, y=media_AMG, fill=Solo)) + geom_point(shape=21, size=3) Observe que PV1, PV5 e R apresentaram \\(n &lt; 10\\). "],
["análise-exploratória-de-dados-aed.html", "10 Análise Exploratória de Dados (AED) 10.1 Algumas funções de resumo 10.2 Descrição gráfica 10.3 Aplicação de modelos 10.4 Exercícios", " 10 Análise Exploratória de Dados (AED) A AED não é um processo com um conjunto de regras rígidas. Mais do que qualquer coisa, é uma estado de espírito. Durante as fazes iniciais de AED, devemos ser livres para investigar cada ideia que ocorra. À medida que a exploração segue, nos direcionamos para algumas áreas particularmente produtivas que, por fim, deverão ser escritas e comunicadas. É considera uma fase importante de qualquer análise, pois mesmo se as perguntas já foram formuladas, sempre será necessário pesquisar a qualidade dos dados que temos em mãos. Assim, a limpeza de dados é apenas uma aplicação da AED, na qual serão necessárias as ferramentas de visualização, transformação e modelagem. A AED é o cálculo das estatísticas tradicionais, alguns exemplos: Univariadas: média, mediana, desvio padrão, 1º e 3º quartis, mínimo, máximo, coeficientes die variação, de assimetria e curtosis, histogramas, boxplot, gráficos de regressão, gráficos de dispersão, entre outros. Bivariadas – análise de cluster, análise de componentes principais, análise de fatores e análise de variância. 10.1 Algumas funções de resumo Aliadas à média e à contagem, várias outras funções podem ser utilizadas em R. Medidas de localização A função median() retorna a mediana do conjunto de dados, ou seja, um valor onde \\(50\\%\\) de \\(x\\) está acima e \\(50\\%\\) está abaixo dela. Já a média mean() é a soma dividida pelo comprimento. Assim, a mediana não é influenciada por valores extremos, diferente da média. Compare a diferença entre média e mediana para as variáveis ARGILA e em seguida P. $$ = \\[\\begin{cases} \\text{Se n é ímpar, n=2k+1, então } x_{(k+1)} \\\\ \\text{Se n é par, n=2k, então } \\frac{x_{(k)} + x_{(k+1)}}{2} \\end{cases}\\] $$ Entrada de dados library(tidyverse) URL &lt;- &quot;https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/geomorfologia.txt&quot; geomorfologia&lt;-read.table(URL,header = TRUE) ARGILA # Para Argila geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(Media = mean(ARGILA, na.rm = TRUE), Mediana = median(ARGILA, na.rm = TRUE)) ## # A tibble: 3 x 3 ## SUP Media Mediana ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 I 21.1 20.7 ## 2 II 14.8 14.3 ## 3 III 10.1 10.1 geomorfologia %&gt;% ggplot(aes(x=ARGILA,fill=SUP)) + geom_histogram(bins=15,color=&quot;black&quot;)+ facet_wrap(~SUP,scales=&quot;free&quot;) Fósforo (P) # Para P geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(Media = mean(P, na.rm = TRUE), Mediana = median(P, na.rm = TRUE)) ## # A tibble: 3 x 3 ## SUP Media Mediana ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 I 17.8 12 ## 2 II 34.9 12.5 ## 3 III 14.0 9 geomorfologia %&gt;% ggplot(aes(x=P,fill=SUP)) + geom_histogram(bins=15,color=&quot;black&quot;)+ facet_wrap(~SUP,scales=&quot;free&quot;) Medidas de dispersão O desvio padrão sd() é a medida de dispersão padrão. Outras medidas podem ser utilizadas, como a variação interquartil IQR() e o desvio absoluto médio mad() são equivalentes robustos que podem ser mais úteis se você tiver outliers. # Para P geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(Media = mean(P, na.rm = TRUE), Mediana = median(P, na.rm = TRUE), DP=sd(P, na.rm = TRUE), IQR=IQR(P, na.rm = TRUE), DA_mediano = mad(P, na.rm = TRUE)) ## # A tibble: 3 x 6 ## SUP Media Mediana DP IQR DA_mediano ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 I 17.8 12 13.2 19 11.9 ## 2 II 34.9 12.5 47.5 39.5 15.6 ## 3 III 14.0 9 14.7 10 7.41 Medidas de classificação São os valores mínimo/máximo e os quantis. Quantis são generalizações da mediana. Por exemplo, quantile(x, 0.25) encontrará o valor de x que é maior que \\(25\\%\\) dos valores e menor do que os \\(75\\%\\) restantes. Já quantile(x, 0.75) encontrará o valor de x que é maior que \\(75\\%\\) dos valores e menor do que os \\(25\\%\\) restantes. # Para P geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(Media = mean(P, na.rm = TRUE), Mediana = median(P, na.rm = TRUE), DP=sd(P, na.rm = TRUE), IQR=IQR(P, na.rm = TRUE), DA_mediano = mad(P, na.rm = TRUE), Mínimo = min(P, na.rm = TRUE), Q1 = quantile(P, 0.25, na.rm = TRUE), Q3 = quantile(P, 0.75, na.rm = TRUE), Máximo = max(P, na.rm = TRUE)) ## # A tibble: 3 x 10 ## SUP Media Mediana DP IQR DA_mediano Mínimo Q1 Q3 Máximo ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 I 17.8 12 13.2 19 11.9 4 6 25 42 ## 2 II 34.9 12.5 47.5 39.5 15.6 2 4 43.5 209 ## 3 III 14.0 9 14.7 10 7.41 3 4 14 56 Contagens Vamos agora contar o número de observações e o número de valores não faltantes, utilizando as funções n() e sum(!is.na(x)): # Para P geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(Media = mean(P, na.rm = TRUE), Mediana = median(P, na.rm = TRUE), DP=sd(P, na.rm = TRUE), IQR=IQR(P, na.rm = TRUE), DA_mediano = mad(P, na.rm = TRUE), Mínimo = min(P, na.rm = TRUE), Q1 = quantile(P, 0.25, na.rm = TRUE), Q3 = quantile(P, 0.75, na.rm = TRUE), Máximo = max(P, na.rm = TRUE), N=n(), N_na = sum(!is.na(P))) ## # A tibble: 3 x 12 ## SUP Media Mediana DP IQR DA_mediano Mínimo Q1 Q3 Máximo N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 I 17.8 12 13.2 19 11.9 4 6 25 42 17 ## 2 II 34.9 12.5 47.5 39.5 15.6 2 4 43.5 209 62 ## 3 III 14.0 9 14.7 10 7.41 3 4 14 56 27 ## # ... with 1 more variable: N_na &lt;int&gt; Contagens e proporções de valores lógicos sum(x &gt; 10), mean(y == 0). Quando usado com funções numéricas, TRUE é convertido em \\(1\\), e FALSE em \\(0\\). Isso torna sum() e mean() muito úteis: sum(x) retorna o número de TRUE em x e mean(x) retorna a proporção de valores verdadeiros. Por exemplo, em cada supefície geomórfica, vamos calcular o número e a proporção de valores de tor de fósforo disponível no solo (P) inferiores a 10 \\(mg /dm^3\\). # Para P geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(Media = mean(P, na.rm = TRUE), Mediana = median(P, na.rm = TRUE), DP=sd(P, na.rm = TRUE), IQR=IQR(P, na.rm = TRUE), DA_mediano = mad(P, na.rm = TRUE), Mínimo = min(P, na.rm = TRUE), Q1 = quantile(P, 0.25, na.rm = TRUE), Q3 = quantile(P, 0.75, na.rm = TRUE), Máximo = max(P, na.rm = TRUE), N=n(), N_na = sum(!is.na(P)), n10=sum(P&lt;10), n10p=mean(P&lt;10)) ## # A tibble: 3 x 14 ## SUP Media Mediana DP IQR DA_mediano Mínimo Q1 Q3 Máximo N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 I 17.8 12 13.2 19 11.9 4 6 25 42 17 ## 2 II 34.9 12.5 47.5 39.5 15.6 2 4 43.5 209 62 ## 3 III 14.0 9 14.7 10 7.41 3 4 14 56 27 ## # ... with 3 more variables: N_na &lt;int&gt;, n10 &lt;int&gt;, n10p &lt;dbl&gt; Medidas da Forma da Distribuição As medidas da forma da distribuição são os coeficientes de assimetria e curtose. Assimetria - é uma medida da simetria da distribuição de frequência. Ela mostra se os desvios da média são maiores para um lado da distribuição do que para o outro. Usualmente, a estimativa do Coeficiente de Assimetria pode ser calculada pela fórmula: \\[ G_1 = \\frac{n}{(n-1)(n-2)} \\cdot \\frac{\\sum_{i=1}^n(x_i - \\bar{x})^3}{s^3} \\] Vamos utilizar a função skewness() do pacote agricolae para calcular o coeficente de assimetria. # Para P geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(Media = mean(P, na.rm = TRUE), Mediana = median(P, na.rm = TRUE), DP=sd(P, na.rm = TRUE), IQR=IQR(P, na.rm = TRUE), DA_mediano = mad(P, na.rm = TRUE), Mínimo = min(P, na.rm = TRUE), Q1 = quantile(P, 0.25, na.rm = TRUE), Q3 = quantile(P, 0.75, na.rm = TRUE), Máximo = max(P, na.rm = TRUE), N=n(), N_na = sum(!is.na(P)), n10=sum(P&lt;10), n10p=mean(P&lt;10), G1 = agricolae::skewness(P)) ## # A tibble: 3 x 15 ## SUP Media Mediana DP IQR DA_mediano Mínimo Q1 Q3 Máximo N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 I 17.8 12 13.2 19 11.9 4 6 25 42 17 ## 2 II 34.9 12.5 47.5 39.5 15.6 2 4 43.5 209 62 ## 3 III 14.0 9 14.7 10 7.41 3 4 14 56 27 ## # ... with 4 more variables: N_na &lt;int&gt;, n10 &lt;int&gt;, n10p &lt;dbl&gt;, G1 &lt;dbl&gt; Se as observações apresentam distribuição simétrica temos \\(G_1=0\\), ou próximas a \\(0\\). O coeficiente de assimetria é o indicativo mais comum de Normalidade. Em dados assimétricos, existem dúvidas sobre qual medida de tendência central devemos utilizar para resumir os dados. Nesses casos, comparações entre médias de diferentes conjuntos de observações são não confiáveis, uma vez que a variância pode diferir substancialmente de um conjunto de observações para outro. geomorfologia %&gt;% ggplot(aes(x=P,y=..density..)) + geom_histogram(bins=30, color=&quot;black&quot;, fill=&quot;white&quot;)+ facet_wrap(~SUP, scales = &quot;free&quot;)+ geom_density(alpha=0.1,fill=&quot;red&quot;) Curtose - Indica o grau de achatamento de uma distribuição, é a medida do peso das caudas da distribuição. Se as observações seguem uma distribuição normal, então o coeficiente de curtose é zero, e sua estimativa é dado por: \\[ G_2 = \\frac{\\frac{\\sum{i=1}^n(x-\\bar{x})^4}{s^4}}{(n-3)(n-2)(n-1)}-3 \\cdot \\frac{(n-1)^2}{(n-2)(n-3)} \\] Vamos utilizar a função kurtosis() do pacote agricolae para calcular o coeficente de curtose. # Para P geomorfologia %&gt;% group_by(SUP) %&gt;% summarize(Media = mean(P, na.rm = TRUE), Mediana = median(P, na.rm = TRUE), DP=sd(P, na.rm = TRUE), IQR=IQR(P, na.rm = TRUE), DA_mediano = mad(P, na.rm = TRUE), Mínimo = min(P, na.rm = TRUE), Q1 = quantile(P, 0.25, na.rm = TRUE), Q3 = quantile(P, 0.75, na.rm = TRUE), Máximo = max(P, na.rm = TRUE), N=n(), N_na = sum(!is.na(P)), n10=sum(P&lt;10), n10p=mean(P&lt;10), G1 = agricolae::skewness(P), G2 = agricolae::kurtosis(P)) ## # A tibble: 3 x 16 ## SUP Media Mediana DP IQR DA_mediano Mínimo Q1 Q3 Máximo N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 I 17.8 12 13.2 19 11.9 4 6 25 42 17 ## 2 II 34.9 12.5 47.5 39.5 15.6 2 4 43.5 209 62 ## 3 III 14.0 9 14.7 10 7.41 3 4 14 56 27 ## # ... with 5 more variables: N_na &lt;int&gt;, n10 &lt;int&gt;, n10p &lt;dbl&gt;, G1 &lt;dbl&gt;, ## # G2 &lt;dbl&gt; geomorfologia %&gt;% ggplot(aes(x=P,y=..density..)) + geom_histogram(bins=30, color=&quot;black&quot;, fill=&quot;white&quot;)+ facet_wrap(~SUP, scales = &quot;free&quot;)+ geom_density(alpha=0.1,fill=&quot;red&quot;) 10.2 Descrição gráfica Visualizar a distribuição de uma variável dependerá se a variável é categórica ou contínua. Uma variável categórica só pode assumir um pequeno conjunto de valores. Em R essas variáveis são geralmente salvas na forma de fatores ou strings. Importação dos dados Vamos realizar a importação, via web, do banco de dados transectos.txt. URL &lt;- &quot;https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/transectos.txt&quot; transectos&lt;-read.table(URL,header = TRUE) glimpse(transectos) ## Rows: 302 ## Columns: 7 ## $ Amostra &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17... ## $ Transecto &lt;chr&gt; &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I... ## $ X &lt;int&gt; 0, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, ... ## $ Y &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... ## $ Argila &lt;int&gt; 57, 58, 64, 65, 66, 70, 71, 72, 73, 72, 70, 64, 69, 69, 6... ## $ Silte &lt;int&gt; 13, 13, 16, 16, 14, 15, 17, 18, 19, 20, 19, 21, 19, 18, 2... ## $ Areia &lt;int&gt; 30, 29, 20, 19, 20, 15, 12, 10, 8, 8, 11, 15, 12, 13, 12,... As colunas X e Y denotam as coordenadas de cada ponto amostral dentro do gradeado experimental. Vamos vizualizar o gradeado. transectos %&gt;% ggplot(aes(x=X, y=Y))+ geom_point(size=2)+ theme_minimal() glimpse(transectos) ## Rows: 302 ## Columns: 7 ## $ Amostra &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17... ## $ Transecto &lt;chr&gt; &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I... ## $ X &lt;int&gt; 0, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, ... ## $ Y &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... ## $ Argila &lt;int&gt; 57, 58, 64, 65, 66, 70, 71, 72, 73, 72, 70, 64, 69, 69, 6... ## $ Silte &lt;int&gt; 13, 13, 16, 16, 14, 15, 17, 18, 19, 20, 19, 21, 19, 18, 2... ## $ Areia &lt;int&gt; 30, 29, 20, 19, 20, 15, 12, 10, 8, 8, 11, 15, 12, 13, 12,... Agora, vamos criar um gráfico de barras para visualizar a variável categórica Transecto, ou seja, o número de observações em cada transecto. transectos %&gt;% ggplot(aes(x = Transecto))+ geom_bar(fill=&quot;lightblue&quot;, color=&quot;black&quot;) Muitas vezes precisamos modificar a escala dos eixos para melhorar e focar nossa visualização nas diferenças, então, vamos utilizar a função coord_cartesian(), aliada aos argumentos xmin e/ou ymin, ambos os argumentos deverãp receber um vetor com dois valores para a definição do menor e maior valor da escala: transectos %&gt;% ggplot(aes(x = Transecto))+ geom_bar(fill=&quot;lightblue&quot;,color=&quot;black&quot;) + coord_cartesian(ylim= c(55,63)) Agora vamos visualizar a tabela com os valores contados. transectos %&gt;% count(Transecto) ## Transecto n ## 1 I 58 ## 2 II 61 ## 3 III 63 ## 4 IV 62 ## 5 V 58 Uma variável contínua pode assumir qualquer valor de um conjunto infinito de valores ordenados. Para examinarmos a distribuição de uma variável contínua, vamos utilizar o histograma. Argila transectos %&gt;% ggplot(aes(x=Argila)) + geom_histogram(bins=20, color=&quot;black&quot;,fill=&quot;lightgray&quot;) Podemos sobrepor vários histogramas no mesmo gráfico, para isso, utilize geom_freqpoly(). Observe que vamos criar os polígonos a partir da densidade e frequência \\(d_i\\): \\[ d_i = \\frac{f_i}{\\Delta_i} \\] onde, \\(f_i\\) é a frequência relativa dada pela contagem de cada classe individual \\(n_i\\), dividida pelo número total de observações (\\(n\\)). \\[ f_i = \\frac{n_i}{n} \\] \\(\\Delta_i\\) é o intervalo de cada classe específica \\(i\\). transectos %&gt;% ggplot(aes(x=Argila, color=Transecto, y= ..density..)) + geom_freqpoly() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. O histograma fornece informação sobre: * Tipo de distribuição; * Unimodal ou multimodal; * Presença de valores extremos (outliers); * Variabilidade. Outra possibilidade é o uso do Boxplot, para isso vamos verificar a variável Silte: transectos %&gt;% ggplot(aes(y=Silte)) + geom_boxplot() Vamos modificar o gráfico, alterando as cores e a escala do eixo X para modificar a caixa. transectos %&gt;% ggplot(aes(y=Silte)) + geom_boxplot(color=&quot;black&quot;,fill=&quot;lightblue&quot;)+ coord_cartesian(xlim=c(-1,1))+ theme_minimal() Podemos construir o boxplot segmentado por transecto. transectos %&gt;% ggplot(aes(y=Silte, x=Transecto, fill=Transecto)) + geom_boxplot() Para facilitar a visualização da tendência, pode-se reordenar Transecto com base no valor médio da variável estudada (teor de silte do solo, no caso). transectos %&gt;% ggplot(aes(y=Silte, x=reorder(Transecto,Silte,mean), fill=Transecto)) + geom_boxplot() Se temos nomes longos, podemos rotacionar o gráfico 90º com coord_flip(). transectos %&gt;% ggplot(aes(y=Silte, x=reorder(Transecto, Silte, mean), fill=Transecto)) + geom_boxplot()+ coord_flip() Violin plot O violin plot é um método de visualizar dados numéricos. É semelhante ao boxplot, com a adição de um gráfico de densidade girado em cada lado. Essa representação, portanto, também mostram a densidade de probabilidade dos dados em valores diferentes. Normalmente, um gráfico de violino incluirá todos valores que estão no boxplot: um marcador para a mediana dos dados, uma caixa ou marcador indicando o intervalo interquartil e, possivelmente, todos os pontos de amostra, se o número de amostras não for muito alto. A diferença é particularmente útil quando a distribuição de dados é multimodal (mais de um pico). Neste caso, um gráfico de violino mostra a presença de diferentes picos, sua posição e amplitude relativa. transectos %&gt;% ggplot(aes(y=Silte, x=reorder(Transecto, Silte, mean), fill=Transecto)) + geom_violin(trim = FALSE)+ stat_summary(fun = median, geom = &quot;point&quot;, shape=21, size=3, color=&quot;black&quot;, fill=&quot;gray&quot;) + theme(legend.position=&quot;none&quot;) A densidade de distribuição dos pontos pode ser visualizada com a função geom_dotplot() par aa apresentação dos pontos amostrais. transectos %&gt;% ggplot(aes(x=Transecto,y=Silte))+ geom_violin(trim = FALSE) + geom_dotplot(binaxis=&#39;y&#39;, stackdir=&#39;center&#39;, dotsize=1) Muitas vezes, podemos mesclar o boxplot com o violin plot. A largura das caixas do boxplot pode ser controlada com o argumento width. transectos %&gt;% ggplot(aes(y=Silte, x=reorder(Transecto, Silte, mean), fill=Transecto)) + geom_violin(trim=FALSE, fill=&quot;lightgray&quot;)+ geom_boxplot(width=0.1)+ theme_classic() Função Densidade Acumulada Empírica A função de distribuição cumulativa empírica (empirical cumulative distribution function - ECDF) fornece uma visualização alternativa da distribuição. Em comparação com outras visualizações que dependem da densidade (como geom_histogram()), o ECDF não requer nenhum parâmetro de ajuste e lida com variáveis contínuas e categóricas. A desvantagem é que requer mais treinamento para interpretar com precisão e as tarefas visuais subjacentes são um pouco mais desafiadoras. A função de distribuição acumulada descreve como probabilidades são associadas aos valores ou aos intervalos de valores de uma variável aleatória. Ela representa a probabilidade de uma variável aleatória ser menor ou igual a um valor real \\(x\\). \\[ F(x) = P(X \\le x) \\] Em R pode ser desenhanda com stat_ecdf() transectos %&gt;% ggplot(aes(x=Silte)) + stat_ecdf(geom = &quot;line&quot;) A representação pode ser segmentada por cada categoria da variável categórica. transectos %&gt;% ggplot(aes(x=Silte, color= Transecto)) + stat_ecdf(geom = &quot;line&quot;) As variáveis Argila, Silte e Areia são expressas em porcentagem, assim, poderíamos colocá-las em um mesmo gráfico e adicionar uma legenda para identificar cada uma delas. Podemos realizar essa tarefa utilizando a função gather() do pacote tidyr. Literalmente essa função empilha o banco de dados. Nesse exemplo, vamos criar uma nova variável denominada granulometria que deverá receber repedidamente os nomes das colunas (Areia, Silte e Argila), preservando o valor numérico dessas variáveis que serão empilhados na nova variável valor, como exemlificado na figura abaixo: Figure 10.1: Exemplo simples do comportamento da função gather(). A função tem como argumentos os nomes das duas novas colunas granulometria e valor, sendo o terceiro argumento um vetor identificando as posições das colunas que deverão ser empilhadas (5:7, no caso). transectos %&gt;% gather(granulometria, valor, 5:7) %&gt;% View() Podemos completar o código acima pedindo a partir do ggplot() o boxplot por granulometria em cada posição de X, por exemplo: transectos %&gt;% gather(granulometria, valor, 5:7) %&gt;% ggplot(aes(y=valor, x=as.factor(X),fill=granulometria)) + geom_boxplot()+ theme(axis.text.x=element_text(angle=90, hjus=1,size = rel(0.8))) Ou, podemos pedir para cada transecto Y, no caso: transectos %&gt;% gather(granulometria, valor, 5:7) %&gt;% ggplot(aes(y=valor, x=as.factor(Y),fill=granulometria)) + geom_boxplot()+ theme(axis.text.x=element_text(angle=90, hjus=1,size = rel(0.8))) 10.3 Aplicação de modelos Até agora para a análise exploratória dos dados recomendamos o cálculo de vparias medidas de dispersão e posição, e a representação gráfica, que nos auxiliará na interpretação da forma da distribuição dos dados. O próximo passo é adicionarmos um modelo matemático que descreva o comportamento do dados. Agora vamos aplicar a estimativa da densidade alisa geom_density() ao nosso histograma. transectos %&gt;% ggplot(aes(x=Silte,y=..density..)) + geom_histogram(bins=20, color=&quot;black&quot;,fill=&quot;lightgray&quot;) + geom_density(linetype=2,col=&quot;blue&quot;, lwd=1) Hipóteses estatísticas do teste da normalidade dos dados \\[ \\begin{cases} H_0: \\text{Os dados tem distribuição normal }[X \\sim N(\\mu,\\sigma^2) ]\\\\ H_1: \\text{Os dados não tem distribuição normal} \\end{cases} \\] Todo teste estatístico fornece os valores da estatística do teste e o valor de probabilidade associado a essa estatística \\(p\\), por exemplo: silte &lt;- transectos$Silte shapiro.test(silte) ## ## Shapiro-Wilk normality test ## ## data: silte ## W = 0.98997, p-value = 0.03625 Regra de decisão (\\(\\alpha=0,01\\) ou \\(1\\%\\)) *Se o valor de \\(p \\ge 0,01\\), o teste é não significativo, portanto não rejeitamos \\(H_0\\), e concluímos que os dados suportam a hipótese de uma distribuição normal teórica. *Se \\(p \\le 0,01\\), o teste é significativo, portanto rejeitamos \\(H_0\\), tomamos \\(H_1\\) como verdadeira e concluímos que os dados não suportam a suposição de normalidade. Um gráfico quantil-quantil (ou QQPlot, stat_qq()) é usado para verificar se uma dada variável segue a distribuição normal. Os dados são considerados normalmente distribuídos quando os pontos seguem aproximadamente a linha de referência de 45º (1:1, stat_qq_line()). transectos %&gt;% ggplot(aes(sample = Silte))+ stat_qq(color=&quot;blue&quot;) + stat_qq_line(color=&quot;red&quot;) Uma vez que os dados seguem a distribuição normal, podemos adicionar ao histograma da variável a curva teórica. Para sobrepor a curva da função, adicionamos a opção stat_function(fun = dnorm) e especificamos a forma usando os argumentos mean = mean(silte) e sd = sd(silte) que deve ser passado apra o argumento args na forma de uma lista list(). Se você tem dados ausentes, certifique-se de passar o argumento com na.rm = TRUE para os parâmetros de mean e sd. Finalmente, podemos alterar a cor usando o argumento color = \"red\". transectos %&gt;% ggplot(aes(x=Silte)) + geom_histogram(aes(y=..density..),bins=20, color=&quot;black&quot;,fill=&quot;lightgray&quot;) + stat_function(fun = dnorm, colour = &quot;red&quot;, args = list(mean = mean(silte, na.rm = TRUE), sd = sd(silte, na.rm = TRUE))) Vamos salvar o gráfico em um novo plot. hist_silte &lt;- transectos %&gt;% ggplot(aes(x=Silte)) + geom_histogram(aes(y=..density..),bins=20, color=&quot;black&quot;,fill=&quot;lightgray&quot;) + stat_function(fun = dnorm, colour = &quot;red&quot;, args = list(mean = mean(silte, na.rm = TRUE), sd = sd(silte, na.rm = TRUE))) Para alterar os rótulos dos eixos, vamos apresentar uma nova opção. Nesse caso, usaremos as opções scale_x_continuous e scale_y_continuous, pois essas funões possuem outros argumentos de personalização para os eixos que usaremos a seguir. Em cada um, adicionamos o nome desejado ao argumento do nome como uma string. hist_silte + scale_x_continuous(name = &quot;Teor de Silte no solo\\n(%)&quot;) + scale_y_continuous(name = &quot;Densidade&quot;) Observe que o ggplot também permite o uso de nomes de várias linhas (em eixos e títulos). Aqui, alteramos o rótulo do eixo x para que passe por duas linhas usando o caractere \"\\n\" para quebrar a linha. Agora vamos fazer com que as marcações do eixo x apareçam a cada 2 unidades em vez de 5 usando o argumento breaks = seq (4, 30, 2) em scale_x_continuous. hist_silte + scale_x_continuous(name = &quot;Teor de Silte no solo\\n(%)&quot;, breaks = seq (4, 30, 2)) + scale_y_continuous(name = &quot;Densidade&quot;) Você também pode adicionar um gradiente ao seu esquema de cores que varia de acordo com a frequência dos valores. Para fazer isso, alteramos o argumento aes(y = ..count ..) em geom_histogram() para aes(fill = ..count..). hist_silte + geom_histogram(aes(fill = ..count..),bins=20)+ scale_x_continuous(name = &quot;Teor de Silte no solo\\n(%)&quot;, breaks = seq (4, 30, 2)) + scale_y_continuous(name = &quot;Densidade&quot;) Podemos, personalizar o gradiente alterando as cores de ancoragem para alto e baixo. Para isso, adicionamos a opção scale_fill_gradient ao gráfico com os argumentos Count (o nome da legenda), low (a cor dos valores menos frequentes) e high (a cor dos valores mais frequentes). hist_silte + geom_histogram(aes(fill = ..count..),bins=20)+ scale_x_continuous(name = &quot;Teor de Silte no solo\\n(%)&quot;, breaks = seq (4, 30, 2)) + scale_y_continuous(name = &quot;Densidade&quot;) + scale_fill_gradient(&quot;Count&quot;, low=&quot;blue&quot;, high = &quot;red&quot;) Para representar os diferentes transectos acrescentamos na função geom_histogram um argumento fill = Transecto a aes(). Em segundo lugar, para ver mais claramente o gráfico, adicionamos dois argumentos, position = \"identity\" e alpha = 0.6. Isso controla a posição e a transparência das colunas, respectivamente. Finalmente, você pode personalizar as cores dos histogramas adicionando scale_fill_brewer ao gráfico do pacoteRColorBrewer. hist_silte + geom_histogram(aes(fill = Transecto),bins=20, position=&quot;identity&quot;, alpha=0.6)+ scale_x_continuous(name = &quot;Teor de Silte no solo\\n(%)&quot;, breaks = seq (4, 30, 2)) + scale_y_continuous(name = &quot;Densidade&quot;) + scale_fill_brewer(palette=&quot;Accent&quot;) Modelos de Distribuição – prós e contras Vantagens: fornece uma descrição da distribuição com poucos parâmetros (geralmente só dois). Desvantagem: Distribuição Normal ou lognormal muito raramente são encontradas nas ciências agrárias. Para análise exploratória de dados, modelos de distribuição, geralmente, não são necessários. 10.4 Exercícios 1) O conjunto de dados denominado de BroomBarnFarm.txt foi coletado em uma área de 80 ha no leste da Inglaterra. O solo foi amostrado em intervalos de 40 m. As amostras de solo na profundidade de 0,20 m foram analisadas em laboratório e como resultado temos: 435 valores para cada variável (K, pH e P). (WEBSTER &amp; OLIVER. Geostatistics for Environmental Scientists, Appendix B). Responda as seguintes questões: Calcular a média, a mediana, o desvio padrão, o 1º (Q1) e o 3º (Q3) quartis, os coeficientes de assimetria, de curtosis, de variação (CV), as observações máxima e mínima das 3 variáveis do conjunto de dados. Construa os gráficos Boxplot, histogramas e da função de distribuição acumulada empírica para as 3 variáveis. Discuta o que você observa. Refaça o item anterior com os dados na escala logarítmica. Discuta os resultados. 2) No arquivo geomorfologia.txt que possui dados de atributos de solo de um transecto existe uma coluna classificatória das superfícies geomórficas identificadas na área de estudo. Faça gráficos de dispersão dos dados das variáveis Arg, P e Ca para todo o transecto e, em seguida, para cada uma das 3 superfícies (I, II e III). calcule as estatísticas descritivas destas superfícies que foram identificadas na área (monte uma tabela com: o tamanho da amostra (n), a média, mediana, o desvio-padrão, os coeficientes de assimetria, curtose e de variação). faça gráficos (histogramas, boxplots para descrever as distribuições, quanto as formas, das três variáveis Arg, P e Ca para cada superfície. "],
["referências.html", "Referências", " Referências Andrade, P. F. &amp; Ogliari, P. (2010) Estatística para Ciências Agrárias e Biológicas e Noções de Experimentação. Florianópolis, Ed.: UFSC. Ascencio, A. F. G. &amp; de Campos, E. A. V. (2007) Fundamentos da programação de computadores. 2 ed. ed. São Paulo: Pearson Prentice Hall, 434 p. Bussab, W. O. &amp; Morettin, P. A. (2002) Estatística Básica. 5 ed. São Paulo: Saraiva, p. Magalhães, M. N. &amp; Lima, A. C. P. (2005) Noções de Probabilidade e Estatística. São Paulo: Editora da Universidade de São Paulo, 392 p. Crawley, M. J. (2007) The R Book. UK, Ed. Willey &amp; Sons Ltda, 950 p. (pdf). Forbellone, A. L. V. &amp; Eberspächer, H. F. (2005) Lógica de programação: a construção de algoritmos e estruturas de dados. 3 ed ed. São Paulo: Pearson Prentice Hall, 218 p. Long, J. D. &amp; Teetor, P. (2019) R Cookbook. USA: O’Reilly Media, Inc, https://rc2e.com/. Peternelli, L. A. &amp; Mello, M. P. (2011) Conhecendo o R: uma visão estatística. 2ª ed. Viçosa, MG, Ed. UFV, 185 p. Pimentel-Gomes, F. (2000) Curso de Estatística Experimental. 10ª ed. Piracicaba, SP, Brasil: F. Pimentel-Gomes, 477 p. Vieira, S. (1999) Estatística experimental. 2ª ed. São Paulo, Ed.: Editora Atlas S.A, 185 p. Wickham, H. &amp; Grolemund G. (2019) R for Data Science. https://r4ds.had.co.nz/. "]
]
