[["index.html", "Análise de Dados de Ciência do Solo no R Bem-vindos!!", " Análise de Dados de Ciência do Solo no R Alan R. Panosso alan.panosso@unesp.br &amp; Gener T. Pereira gener.t.pereira@unesp.br 01 a 12 de Fevereiro de 2021 Bem-vindos!! As análises estatísticas e modelagem matemática são amplamente utilizadas na área da Agronomia na Ciência do Solo. Nesse contexto, a correta utilização dos recursos computacionais para decisão e execução das principais técnicas estatísticas e matemáticas é fundamental para a formação do estudante ao nível de pós-graduação, visando uma boa condução das análises de suas pesquisas. Neste contexto, a Ciência de Dados tem destaque mundial, uma vez que todos os campos de estudo e áreas de negócios foram afetados à medida que as pessoas percebem cada vez mais o valor das incríveis quantidades de dados sendo gerados. Mas para extrair valor desses dados, é necessário ser treinado nas habilidades adequadas de ciência de dados. A linguagem de programação R (software livre, de domínio público) se tornou a linguagem de programação de fato para a ciência de dados. Sua flexibilidade, potência, sofisticação e expressividade a tornaram uma ferramenta inestimável para cientistas de dados em todo o mundo. Neste curso pretende-se dar uma introdução às técnicas de programação e à riqueza do ambiente R, destinada aos pós-graduandos iniciantes e intermediários da estatística e da experimentação agronômica e, consequentemente, da ciência de dados. Inicialmente serão abordados tópicos de programação R, para a familiarização dos alunos às estruturas básicas e recursos de programação e visualização de dados. Em seguida serão abordados os temas de estatística descritiva, teste de hipóteses, análise de regressão, análise de variância, e rotinas de diagnósticos, todos desenvolvidos no ambiente R. Você começará com o básico da linguagem, aprenderá como manipular conjuntos de dados, como escrever funções, como visualizar seus dados e como analizá-los. Com os fundamentos fornecidos neste curso, esperamos que você tenha uma base sólida sobre a qual construir sua caixa de ferramentas de ciência de dados na ciência do solo, ou em em sua área de atuação. "],["ambientação.html", "1 Ambientação 1.1 Instalando o R 1.2 Instalando o RStudio", " 1 Ambientação 1.1 Instalando o R Baixe o R do site oficial The R Project for Statistical Computing https://www.r-project.org/ Acesso rápido: Download Salve o arquivo de instalação em um diretório de seu computador e em seguida execute-o. O processo é simples e intuitivo. 1.2 Instalando o RStudio É um ambiente de desenvolvimento integrado (IDE) para o R, disponível em https://rstudio.com/products/rstudio/download/ Escolha o instalador de acordo com o seu sistema operacional. Windows no nosso caso. Novamente, salve o arquivo de instalação em um diretório de seu computador e em seguida execute-o. Após a instalação procure o ícone do R criado pelo instalador e clique nele. Um breve tutorial para instalação do R e do RStudio pode ser encontrado no vídeo abaixo. "],["pacotes-no-r.html", "2 Pacotes no R 2.1 Pacotes básicos 2.2 Instalando pacotes", " 2 Pacotes no R Um pacote é uma coleção de funções, exemplos e documentação. A funcionalidade de um pacote é frequentemente focada em uma metodologia estatística especial\" (Everitt &amp; Hothorn). Figure 2.1: Pacotes no R são coleções de funções, exemoplos e documentações, os quais devem ser previamente instalados e alocados no ambiente por meio da função library ou require. 2.1 Pacotes básicos Liste os pacotes carregados no ambiente com: (.packages()) ## [1] &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [7] &quot;base&quot; Observe que o retorno da função é uma lista de nomes, caracteres (ou strings), na forma de um objeto denominado vetor. Observe que cada pacote (elemento) é referenciado dentro do vetor por um índice, um número inteiro \\([\\;i\\;]\\) apresentado entre colchetes [i], onde \\(i\\) varia de \\(1\\) a \\(7\\), em nosso exemplo. Carregue um pacote, utilize a função library. library(MASS) Ou, utilize a função require. require(car) ## Warning in library(package, lib.loc = lib.loc, character.only = TRUE, ## logical.return = TRUE, : there is no package called &#39;car&#39; Agora, liste novamente os pacotes e observe a diferença no retorno da função. (.packages()) ## [1] &quot;MASS&quot; &quot;stats&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; ## [7] &quot;methods&quot; &quot;base&quot; 2.2 Instalando pacotes Utilizando a opção Install/Packages Instale alguns pacotes: tidyverse agricolae readxl stringr lubridate Os pacotes também podem ser instalados a partir das linhas de comandos (códigos): install.packages(&quot;tidyverse&quot;) install.packages(&quot;agricolae&quot;) install.packages(&quot;readxl&quot;) install.packages(&quot;stringr&quot;) install.packages(&quot;lubridate&quot;) "],["lógica-de-programação.html", "3 Lógica de Programação 3.1 Introdução 3.2 Conceitos básicos", " 3 Lógica de Programação 3.1 Introdução A Lógica pode ser definida como a análise das formas e leis do pensamento, mas não se preocupa com a produção do pensamento, não se preocupa com o conteúdo do pensamento, mas sim com a maneira pela qual os pensamentos são organizados e apresentados, possibilitando que cheguemos a uma conclusão por meio do encadeamento dos argumentos. A lógica é a ciência que estuda as leis do raciocínio. Correção/validação do pensamento. Encadeamento/ordem de ideias. Arte de bem pensar. 3.2 Conceitos básicos Em Lógica um conceito importante é o de Proposição. Proposição: é um enunciado verbal, ao qual deve ser atribuído, sem ambiguidade, um valor lógico verdadeiro (V) ou falso (F). Abstração: Operação mental que observa a realidade e captura apenas os aspectos relevantes para um contexto. Figure 3.1: Passe alguns segundos olhando para a figura abaixo e diga o que você consegue abstrair dela. Perceba que a realidade é a mesma, isto é, uma figura em preto e branco. Mas, dependendo da observação da realidade, você pode ter abstrações diferentes. Por isso, a abstração depende mais do observador do que da realidade observada. A tarefa de programar sistemas computacionais envolve o exercício constante da abstração da realidade e sua codificação em uma linguagem de programação. Programação: A tarefa de programar sistemas computacionais e envolve o exercício constante da abstração da realidade e sua codificação em uma linguagem de programação. Figure 3.2: Exemplo de programação de um sistema para exibir a média de dois números #Entrada a&lt;-6 b&lt;-8 #Processamento resultado &lt;- (a+b)/2 #Saída resultado ## [1] 7 Linguagem de programação: conjunto de palavras e regras que permitem comunicar ao computador o que este deve executar. Em computação, uma linguagem de programação é a ferramenta de comunicação entre o programador que visa resolver um problema e o computador que irá ajudá-lo a resolver. Tipos de linguagens de programação: 1 - Totalmente codificadas em binário (0´s e 1´s). 2 - Usa instruções simbólicas para representar os 0´s e 1´s. 3 - Voltadas para facilitar o raciocínio humano. Figure 3.3: Resumo dos tipos de linguagem de programação. Se o computador só entende linguagem de máquina, o que deve ser feito para que ele entenda programas em linguagem assembly ou de alto nível? Tradutores no contexto de linguagens de programação são programas que recebem como entrada um programa em linguagem assembly ou de alto nível (dita linguagem fonte) e produzem como saída as instruções deste programa traduzidas para linguagem de máquina. Existem basicamente três tipos de tradutores: + Compilador + Interpretador + Assembler Figure 3.4: O Compilador traduz de uma vez só todo o programa escrito em linguagem de alto nível (código-fonte) para um programa equivalente escrito em linguagem de máquina (código-objeto). Por sua vez, o Interpretador, como o R, traduz (sem gerar código-objeto) e em seguida executa, uma-a-uma, as instruções de um programa em linguagem de alto nível (código-fonte). "],["introdução-à-ciência-dos-dados.html", "4 Introdução à Ciência dos Dados 4.1 Importação 4.2 Organização 4.3 Transformação dos dados 4.4 Visualização 4.5 Modelação 4.6 Comunicação 4.7 Programação", " 4 Introdução à Ciência dos Dados A Ciência dos Dados, ou Data Science, é uma área interdisciplinar voltada para o estudo e a análise de dados, estruturados e não-estruturados, que visa a extração de conhecimento, detecção de padrões e/ou obtenção de variáveis para possíveis tomadas de decisão. O modelo base das ferramentas necessárias em um projeto típico de ciência dos dados é parecido com isso: Figure 4.1: Modelo base de um projeto de Ciência dos Dados. 4.1 Importação Primeiro devemos importar os dados no R. Ou seja, pegar os dados armazenados em um arquivo, base de dados ou na Web e carregá-los em uma estrutuda de dados no R. Sem eles no R, não conseguiremos fazer Data Science. Para essa prática, vamos utilizar um banco de dados oriundo de um estudo geomorfológico. Importação via web Acesse o banco de dados na web: Clique no link para o arquivo em txt geomorfologia.txt. # definir o caminho URL &lt;- &quot;https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/geomorfologia.txt&quot; # Importação dados&lt;-read.table(URL, header = TRUE) # Argumento para cabeçalho na primeira linha # Inspeção do banco de dados head(dados) # mostra o 6 primeiros registros ## SUP Solo Amostra X AMG AG AM AF AMF SILTE ARGILA S_A AF_AG P pH ## 1 I LV 1 0 0.2 3.72 20.4 22.9 30.0 1.2 21.5 0.05 6.16 42 4.2 ## 2 I LV 2 25 0.1 4.27 22.6 23.6 28.4 1.2 20.4 0.05 5.53 22 3.8 ## 3 I LV 3 50 0.7 5.00 22.7 22.2 26.9 1.2 21.4 0.05 4.44 41 4.8 ## 4 I LV 4 75 0.4 3.80 23.7 24.4 26.7 0.6 20.5 0.02 6.42 27 4.0 ## 5 I LV 5 100 0.4 3.10 22.3 24.6 26.9 2.1 20.7 0.10 7.94 11 4.4 ## 6 I LV 6 125 0.4 3.80 23.8 19.1 27.1 2.2 23.5 0.09 5.03 12 4.0 ## K Ca Mg H_Al SB T V ## 1 0.27 1.4 0.3 5.2 1.97 7.17 27 ## 2 0.11 0.4 0.1 5.8 0.61 6.41 10 ## 3 0.34 2.4 0.4 4.2 3.14 7.34 43 ## 4 0.13 0.7 0.1 5.2 0.93 6.13 15 ## 5 0.11 1.4 0.3 4.2 1.81 6.01 30 ## 6 0.14 0.6 0.1 5.2 0.84 6.04 14 Importação via Excel Acesse o banco de dados para essa prática, denominado geomorfologia.xlsx, salve o arquivo em uma pasta de seu computador. Figure 4.2: Na aba Environment selecione a opção Import Dataser e escolha From Excel Figure 4.3: 1) Clique em Browse, acesse a pasta na qual você salvou o arquivo; 2) selecione o arquivo geomorfologia.xlsx; 3) clique em Open. Figure 4.4: Pré-visualização dos dados, observe que o código de importação é apresentado abaixo dessa janela. Copie esse código, e clique em CANCEL. Cole as linhas de código no script do R e as execute, para ter a importação dos dados. library(readxl) geomorfologia &lt;- read_excel(&quot;C:/Users/Panosso/Desktop/geomorfologia.xlsx&quot;) View(geomorfologia) Figure 4.5: Após executar o código, os dados devem ser apresentados dessa forma. 4.2 Organização Uma vez que os dados estão no R, a próxima etapa é organizá-los, ou seja, armazená-los de uma forma consistente que combine a semântica da base de dados com a maneira com a qual eles são armazenados. Cada coluna é uma variável e cada linha é uma observação. Figure 4.6: Exemplo de dados organizados em planilha eletrônica, onde cada coluna é uma variável e cada linha é uma observação, ou registro. Observação: O R, como a maioria dos softwares estatísticos, utiliza o ponto como separador decimal, ou seja, como o símbolo usado para separar a parte inteira da parte complementar não inteira da representação decimal do numeral de um real (ponto flutuante). Portanto, aconselhamos você a padronizar o separador decimar do seu computador. Para isso sigua os passos abaixo: Figure 4.7: Acesse o PAINEL DE CONTROLE, na opção REGIÃO clique em CONFIGURAÇÕES ADICIONAIS e modifique o SÍBOLO DECIMAL para PONTO e o SÍMBOLO DE AGRUPAMENTO DE DÍGITO para VÍRGULA. Vamos conhecer a estrutura do nosso banco de dados, a partir da função str. str(dados) ## &#39;data.frame&#39;: 106 obs. of 22 variables: ## $ SUP : chr &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ... ## $ Solo : chr &quot;LV&quot; &quot;LV&quot; &quot;LV&quot; &quot;LV&quot; ... ## $ Amostra: int 1 2 3 4 5 6 7 8 9 10 ... ## $ X : int 0 25 50 75 100 125 150 175 200 225 ... ## $ AMG : num 0.2 0.1 0.7 0.4 0.4 0.4 1.2 0.8 1.1 1.2 ... ## $ AG : num 3.72 4.27 5 3.8 3.1 3.8 3.6 4.7 4.5 5.9 ... ## $ AM : num 20.4 22.6 22.7 23.7 22.3 23.8 23.1 25.8 25.5 32.8 ... ## $ AF : num 22.9 23.6 22.2 24.4 24.6 19.1 21.7 21.1 18.9 19.8 ... ## $ AMF : num 30 28.4 26.9 26.7 26.9 27.1 26.5 24.7 25.4 21.7 ... ## $ SILTE : num 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ... ## $ ARGILA : num 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ... ## $ S_A : num 0.05 0.05 0.05 0.02 0.1 0.09 0.03 0.01 0.11 0.01 ... ## $ AF_AG : num 6.16 5.53 4.44 6.42 7.94 5.03 6.03 4.49 4.2 3.36 ... ## $ P : num 42 22 41 27 11 12 11 16 38 25 ... ## $ pH : num 4.2 3.8 4.8 4 4.4 4 4.8 5.4 4.4 5.2 ... ## $ K : num 0.27 0.11 0.34 0.13 0.11 0.14 0.23 0.28 0.19 0.14 ... ## $ Ca : num 1.4 0.4 2.4 0.7 1.4 0.6 1.6 3.3 1.6 2.9 ... ## $ Mg : num 0.3 0.1 0.4 0.1 0.3 0.1 0.7 1.3 0.5 1.7 ... ## $ H_Al : num 5.2 5.8 4.2 5.2 4.2 5.2 3.4 2.5 5.2 3.1 ... ## $ SB : num 1.97 0.61 3.14 0.93 1.81 0.84 2.53 4.88 2.29 4.74 ... ## $ T : num 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ... ## $ V : num 27 10 43 15 30 14 43 66 31 60 ... Podemos identificar que nosso banco de dados é composto por 106 linhas e 22 colunas. As duas primeiras colunas são do tipo texto (chr - character) e as demais colunas são numéricas (num - numeric). 4.3 Transformação dos dados Literalmente, recortar o banco de dados, assim podemos focar nas observações de interesse. Criar novas variáveis em função das existentes e calcular, por exemplo, um resumo estatístico desse conjunto de interesse. Por exemplo, vamos selecionar somente os solos do tipo LV. # Criar um filtro f &lt;- dados$Solo == &quot;LV&quot; # Criar um banco de dados auxiliar da da &lt;- dados[f,] # Vamos ver a estrutura desse banco auxiliar str(da) ## &#39;data.frame&#39;: 16 obs. of 22 variables: ## $ SUP : chr &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ... ## $ Solo : chr &quot;LV&quot; &quot;LV&quot; &quot;LV&quot; &quot;LV&quot; ... ## $ Amostra: int 1 2 3 4 5 6 7 8 9 10 ... ## $ X : int 0 25 50 75 100 125 150 175 200 225 ... ## $ AMG : num 0.2 0.1 0.7 0.4 0.4 0.4 1.2 0.8 1.1 1.2 ... ## $ AG : num 3.72 4.27 5 3.8 3.1 3.8 3.6 4.7 4.5 5.9 ... ## $ AM : num 20.4 22.6 22.7 23.7 22.3 23.8 23.1 25.8 25.5 32.8 ... ## $ AF : num 22.9 23.6 22.2 24.4 24.6 19.1 21.7 21.1 18.9 19.8 ... ## $ AMF : num 30 28.4 26.9 26.7 26.9 27.1 26.5 24.7 25.4 21.7 ... ## $ SILTE : num 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ... ## $ ARGILA : num 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ... ## $ S_A : num 0.05 0.05 0.05 0.02 0.1 0.09 0.03 0.01 0.11 0.01 ... ## $ AF_AG : num 6.16 5.53 4.44 6.42 7.94 5.03 6.03 4.49 4.2 3.36 ... ## $ P : num 42 22 41 27 11 12 11 16 38 25 ... ## $ pH : num 4.2 3.8 4.8 4 4.4 4 4.8 5.4 4.4 5.2 ... ## $ K : num 0.27 0.11 0.34 0.13 0.11 0.14 0.23 0.28 0.19 0.14 ... ## $ Ca : num 1.4 0.4 2.4 0.7 1.4 0.6 1.6 3.3 1.6 2.9 ... ## $ Mg : num 0.3 0.1 0.4 0.1 0.3 0.1 0.7 1.3 0.5 1.7 ... ## $ H_Al : num 5.2 5.8 4.2 5.2 4.2 5.2 3.4 2.5 5.2 3.1 ... ## $ SB : num 1.97 0.61 3.14 0.93 1.81 0.84 2.53 4.88 2.29 4.74 ... ## $ T : num 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ... ## $ V : num 27 10 43 15 30 14 43 66 31 60 ... Vamos continuar o processo de filtragem e selecionar somente as colunas SUP, ARGILA, SILTE e T. da&lt;-da[,c(1,11,10,21)] str(da) ## &#39;data.frame&#39;: 16 obs. of 4 variables: ## $ SUP : chr &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ... ## $ ARGILA: num 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ... ## $ SILTE : num 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ... ## $ T : num 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ... Vamos criar uma nova variável, ARG_SILT a partir da soma dos valores de ARGILA + SILTE, para isso vamos utilizar o símbolo de colunas cifrão ($). Em seguida, vamos aplicar a transformação logarítmica aos dados de T. da$ARG_SILT &lt;- da$ARGILA + da$SILTE da$Log_T &lt;- log10(da$T) str(da) ## &#39;data.frame&#39;: 16 obs. of 6 variables: ## $ SUP : chr &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ... ## $ ARGILA : num 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ... ## $ SILTE : num 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ... ## $ T : num 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ... ## $ ARG_SILT: num 22.7 21.6 22.6 21.1 22.8 25.7 23.8 22.9 24.5 18.7 ... ## $ Log_T : num 0.856 0.807 0.866 0.787 0.779 ... Agora vamos gerar um resumo estatístico para esses dados. A primeira coluna é do tipo texto, então, deve ser retirada do banco de dados antes de realizarmos os cálculos. Para isso, utilizamos o índice \\(-1\\) na dimensão das colunas do objeto da, ou seja, estamos retirando a coluna 1 SUP de da. # Número de observações apply(da[,-1],2,length) ## ARGILA SILTE T ARG_SILT Log_T ## 16 16 16 16 16 # Média apply(da[,-1],2,mean) ## ARGILA SILTE T ARG_SILT Log_T ## 21.1937500 1.2125000 6.2618750 22.4062500 0.7920605 # Mediana apply(da[,-1],2,median) ## ARGILA SILTE T ARG_SILT Log_T ## 20.8500000 1.1000000 6.0850000 22.6500000 0.7842487 # Variância apply(da[,-1],2,var) ## ARGILA SILTE T ARG_SILT Log_T ## 2.101958333 0.782500000 0.890589583 3.015291667 0.004318016 # Desvio Padrão apply(da[,-1],2,sd) ## ARGILA SILTE T ARG_SILT Log_T ## 1.44981321 0.88459030 0.94371054 1.73645952 0.06571161 # Podemos utilizar a função summary. summary(da[,-1]) ## ARGILA SILTE T ARG_SILT ## Min. :18.50 Min. :0.200 Min. :4.840 Min. :18.70 ## 1st Qu.:20.48 1st Qu.:0.475 1st Qu.:5.760 1st Qu.:21.32 ## Median :20.85 Median :1.100 Median :6.085 Median :22.65 ## Mean :21.19 Mean :1.212 Mean :6.262 Mean :22.41 ## 3rd Qu.:22.18 3rd Qu.:2.125 3rd Qu.:7.213 3rd Qu.:23.20 ## Max. :23.50 Max. :2.600 Max. :7.840 Max. :25.70 ## Log_T ## Min. :0.6848 ## 1st Qu.:0.7598 ## Median :0.7842 ## Mean :0.7921 ## 3rd Qu.:0.8581 ## Max. :0.8943 Agora podemos gerar o conhecimento, por meio da Visualização e Modelagem. Essas tem suas vantegens e desvantagens as quais são complementares, portanto, quaisquer análises reais farão muitos vezes iteraçoes entre elas. Figure 4.8: Visualização e modelagem são dois processos iterativos, onde a matemática é uma ferramenta essencial para a extração de padrões, declaração e testes de hipóteses. 4.4 Visualização Atividade fundamentalmente humana, uma boa visualização lhe mostrará coisas que não esperava, ou levantará novas questões sobre os dados. Além disso, pode mostrar também que você esta fazendo a pergunta errada, ou que precisa coletar dados diferentes. Visualizações podem surpreender o analista de dados, mas não escalam particularmente bem, por que requerem um humano para interpretá-las. plot(da$ARGILA,da$T) 4.5 Modelação Modelo são ferramentas complementares da visualização. Uma vez que você tenha feito perguntas suficientemente precisas, poderá usar um modelo para respondê-las. Modelos são fundamentalmente matemáticos ou computacionais, então geralmente escala bem. Porém, cada modelo faz suposições e, por sua própria natureza, não podem questionar suas própria hipóteses, ou seja, um modelo não pode nos surpreender. plot(da$ARGILA,da$T) mod&lt;-lm(da$T~da$ARGILA) summary.lm(mod) ## ## Call: ## lm(formula = da$T ~ da$ARGILA) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.4256 -0.4641 -0.1615 0.9560 1.5268 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 6.66574 3.69347 1.805 0.0927 . ## da$ARGILA -0.01906 0.17389 -0.110 0.9143 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.9764 on 14 degrees of freedom ## Multiple R-squared: 0.000857, Adjusted R-squared: -0.07051 ## F-statistic: 0.01201 on 1 and 14 DF, p-value: 0.9143 abline(mod) 4.6 Comunicação É a última etapa do data science, a mais importante. Não importa quão bem bem seus modelos e visualizações o levaram a entender os dados, a menos que você também consiga comunicar seus resultados para outras pessoas. Uma dica importante, é estudar RMarkdown! Ótima linguagem de marcação de texto, utilizada para gerar relatórios em HTML, .doc e pdf. Inclusive, esse material que estamos utilizando no curso. Figure 4.9: https://bookdown.org/yihui/rmarkdown-cookbook/ 4.7 Programação Permeia todas as etapas da Ciência dos Dados. Uma questão recursiva O computador é a ferramenta do cientista de dados. R é um ambiente e linguagem de programação de código aberto para computação estatística, bioinformática e gráficos. Como linguagem de programação, garante a reprodutibilidade das análises. Estudantes podem usar as mesmas ferramentas que os profissionais. Todos podem usar as melhores ferramentas independente do poder financeiro. Qualquer um pode reproduzir as suas análises. Você pode corrigir problemas. Você pode desenvolver suas próprias ferramentas. Linguagem orientada a objetos R (Ross Ihaka e Robert Gentleman). R é uma poderosa linguagem, flexível e possui excelentes facilidades gráficas. R é um projeto open-source e está disponível na internet sobre a General Public License (&lt;www.gnu.org/copyleft/gpl.html&gt; e &lt;www.fsf.org&gt;). "],["tópicos-iniciais.html", "5 Tópicos iniciais 5.1 Identificadores 5.2 Palavras Reservadas 5.3 Regras para os nomes de Identificadores 5.4 Tipos de dados 5.5 Atribuição 5.6 Operadores 5.7 Operação aritmética 5.8 Funções matemáticas e trigonométricas 5.9 Operações Relacionais 5.10 Operações Lógicas 5.11 Exercícios", " 5 Tópicos iniciais 5.1 Identificadores São nomes únicos definidos pelos programadores para identificar/distinguir os elementos de um programa. 5.2 Palavras Reservadas São instruções primitivas que têm significados pré-determinados e fazem parte da estrutura de qualquer linguagem de programação. 5.3 Regras para os nomes de Identificadores 1) Devem começar por um caractere alfabético; 2) Podem ser seguidos por mais caracteres alfabéticos e/ou numéricos; 3) Não é permitido o uso de espaço em branco ou de caracteres especiais, como: @, #, &amp;, ?, $ (exceto o _ e o .); 4) Não poderá ser uma palavra reservada a uma instrução do algoritmo (if, else, for, while, entre outras); *5) Devem ser significativos. Geralmente, desejamos que os nomes dos objetos sejam descritivos, então precisaremos de uma convenção para várias palavras. Recomendamos snake_case, onde você separa palavras minúsculas com _ . eu_uso_snake_case outrasPessoasUsamCamelCase algumas.pessoas.usam.pontos E_algumasPoucas.Pessoas_RENUNCIAMconvenções 5.4 Tipos de dados As fases de Entrada, Processamento e Saída podem manipular vários tipos primitivos de dados, a saber: Figure 5.1: Tipos primitivos de dados Um Caractere SEMPRE deve estar entre \" \". Por exemplo: A, Fone 3333-33333, 1, 3.1415, etc. &quot; Olá, eu sou um texto.&quot; ## [1] &quot; Olá, eu sou um texto.&quot; &quot;1&quot; # não pode ser feito cálculos ## [1] &quot;1&quot; 3.14 # DOUBLE: valor real, de ponto flutuante. ## [1] 3.14 1 # valor numérico inteiro, sufixo L temos números inteiros em vez de double ## [1] 1 pi # constante com o valor de pi ## [1] 3.141593 TRUE # valor lógico ## [1] TRUE FALSE # valor lógico ## [1] FALSE 5.5 Atribuição Serve para atribuir um valor a uma variável/objeto no R. A expressão do lado direito do operador é avaliada e seu resultado é armazenado na variável à esquerda. O operador de atribuição pode ser o &lt;- ou o =, preferencialmente utilizaremos o &lt;- para a criação dos objetos e deixaremos o = para a definição de valores em argumentos dentro da funções. texto&lt;-&quot; Olá, eu sou um texto.&quot; x_chr&lt;-&quot;1&quot; # não pode ser feito cálculo c&lt;-1 # valor numérico inteiro PI&lt;-3.14 # valor real, de ponto flutuante logico_1&lt;-TRUE # valor lógico logico_2&lt;-FALSE # valor lógico 5.6 Operadores Aritméticos: são as operações aritméticas básicas. Operador Tipo Operação Prioridade - Unário Inversão do Sinal 1 + Unário Manutenção do Sinal 1 sqrt(x) Binário Radiciação 2 x^y ou x**y Binário Potenciação 2 % Binário Resto da divisão inteira 3 / Binário Divisão 3 * Binário Multiplicação 3 - Binário Subtração 4 + Binário Adição 4 Relacionais: são operadores binários (de mesma prioridade) que somente retornam os valores lógicos V (TRUE) ou F(FALSE). Operador Comparação &gt; maior que &lt; menor que &gt;= maior ou igual &lt;= menor ou igual == igual a != diferente de Estes somente são usados para efetuar comparações, as quais só podem ser feitas entre dados do mesmo tipo. O resultado de uma comparação é sempre um valor lógico V (TRUE) ou F(FALSE). Lógicos ou Booleanos: são usados para combinar expressões relacionais e lógicas. Também retornam como resultado valores lógicos V (TRUE) ou F(FALSE). Operador Tipo Operação Prioridade NÃO (!) Unário Negação 1 E (&amp;) Binário Conjunção 2 OU (|) Binário Disjunção 3 5.7 Operação aritmética \\[ \\begin{aligned} &amp; a) 1+7 = 8\\\\ &amp; b)1 - 2 \\times10 = 19\\\\ &amp; c) 2^{10} = 1024\\\\ &amp; d) \\frac{10}{3} = 3,33333 \\end{aligned} \\] 1 + 7 1 - 2 * 10 2 ** 10 10/3 5.8 Funções matemáticas e trigonométricas \\[ \\begin{aligned} &amp; a)\\;\\sqrt{9} = 3\\\\ &amp; b)\\;seno\\;\\pi = 0\\\\ &amp; c)\\;5! =120\\\\ &amp; d)\\; e^5 = 148,4132 \\\\ &amp; e=2,718282 \\end{aligned} \\] sqrt(9) sin(pi) factorial(5) exp(5) exp(1) 5.9 Operações Relacionais \\[ \\begin{aligned} &amp; a)\\;7 &gt; 5 \\text{ retorna &#39;verdadeiro&#39;}\\\\ &amp; b)\\;8 \\leq 4 \\text{ retorna &#39;falso&#39;}\\\\ &amp; c)\\;5 = \\frac{25}{5} \\text{ retorna &#39;verdadeiro&#39;}\\\\ &amp; d)\\; 4\\neq 8 \\text{ retorna &#39;verdadeiro&#39;} \\end{aligned} \\] 7 &gt; 5 ; 4 != 8 ## [1] TRUE ## [1] TRUE nome &lt;- &#39;Alan&#39; nome == &#39;Rodrigo&#39; ## [1] FALSE nome == &quot;Alan&quot; ## [1] TRUE 5.10 Operações Lógicas \\[ \\begin{aligned} &amp; a)\\;7 &gt; 5 \\; OU \\; 8 \\leq 4 \\text{ retorna &#39;verdadeiro&#39;}\\\\ &amp; b)\\;5 = \\frac{25}{5} \\; E \\; 4 &gt; 8 \\text{ retorna &#39;falso&#39;} \\\\ &amp; c) \\text{ Não} \\; \\text{TRUE}\\; \\text{retorna &#39;falso&#39;} \\\\ &amp; d) \\text{ Não} \\; \\text{FALSE} \\; \\text{retorna &#39;verdadeiro&#39;} \\end{aligned} \\] 7 &gt; 5 | 8 &lt;= 4 5 == 25/5 &amp; 4 &gt; 8 !TRUE !FALSE x &lt;- c(1, 4, 2, NA, 8) is.na(x) x[!is.na(x)] 5.11 Exercícios Resolva as seguintes expressões: \\[ \\begin{aligned} &amp; a)\\; log\\;3 \\\\ &amp; b)\\; ln\\;10\\\\ &amp; c)\\; e^{2,302585}\\\\ &amp; d)\\; \\sqrt{225}\\\\ &amp; e)\\; 5!\\\\ &amp; f)\\; seno\\;30°\\\\ \\end{aligned} \\] Algumas funções do R Função Significado/ação q() Sair do programa. save.image() Salva o trabalho realizado. ls() Lista todos os objetos da área de trabalho atual. rm(x) Remove o objeto x. rm(x,y) Remove os objetos x e y. rm(list=ls(all=TRUE)) Remove todos os objetos (R Console  Misc/Remover todos os objetos). is.na(x) Verdadeiro se existir dado(s) ausente(s) no objeto x. sqrt(x) raiz quadrada de x. log(x,n) logaritmo de x na base n. log(x) logaritmo neperiano de x. log10(x) logaritmo decimal de x. exp(x)|antilogaritmo - ex. sin(x)|seno de x (em radianos). asin(x)|arco-seno de x. abs(x)|modulo(x). factorial(x)|x !. floor(x)|maior inteiro &lt; x. ceiling(x)|menor inteiro &gt;x. trunc(x)|inteiro de x, descartando seus decimais. round(x, digits=0)|arredondando o valor x para um inteiro. signif(x, digits=6)|apresentar 6 dígitos significativos de x. runif(n)|gera n números aleatórios entre 0 e 1 a partir de uma distribuição uniforme. c()|concatenação, criação de vetores. "],["algoritmos.html", "6 Algoritmos 6.1 Estruturas de Controle 6.2 Exercícios", " 6 Algoritmos Definição: Sequência lógica e não ambígua de instruções que levam à solução de um problema num tempo finito. -Sequência lógica: As instruções devem ser definidas em uma ordem correta. -Não ambígua: A sequência lógica e as instruções não devem dar margem à dupla interpretação. -Solução de um problema: A sequência lógica deve resolver exatamente (nem mais e nem menos) o problema identificado. -Tempo finito: A sequência lógica não deve possuir iterações infinitas. -Um algoritmo é uma solução e não a solução de um problema. -Um problema pode ser resolvido por mais de um algoritmo! SEMPRE. -Tarefas que possuem padrão de comportamento podem ser descritas por um algoritmo. Entender algoritmos é fundamental para desenvolver o raciocínio lógico e conceber uma solução a um dado problema, independente de uma linguagem de programação. (Ex: Fortran, Pascal, C e Python, R). A partir do algoritmo desenvolvido, fica mais fácil implementar o respectivo programa. 6.1 Estruturas de Controle Na criação de algoritmos, utilizamos os conceitos de bloco lógico, entrada e saída de dados, variáveis, constantes, atribuições, expressões lógicas, relacionais e aritméticas, bem como comandos que traduzam esses conceitos de forma a representar o conjunto de ações. Para que esse conjunto de ações se torne viável, deve existir uma perfeita relação lógica intrínseca ao modo pelo qual essas ações são executadas, ao modo pelo qual é regido o fluxo de execução do algoritmo. Por meio das estrutura básicas de controle do fluxo de execução  sequencial, seleção, repetição e da combinação delas  poderemos criar algoritmos para solucionar nossos problemas. Estruturas básicas de um algoritmo: 6.1.1 Sequêncial Representa o Início/Fim, e define uma estrutura onde as instruções serão executadas na ordem que aparecem. Corresponde ao fato de que o conjunto de ações primitivas será executado em uma sequência linear de cima para baixo da esquerda para a direita. Para exemplificarmos, vamos resolver o seguinte exercício. Exemplo: Construa um algoritmo que calcule a média aritmética entre quatro notas bimestrais quaisquer fornecidas: # Entrada n1 &lt;- 4 n2 &lt;- 5 n3 &lt;- 6 n4 &lt;- 7 # Processamento media &lt;- (n1+n2+n3+n4) / 4 # Saída media ## [1] 5.5 6.1.2 Seleção a) Se-Então/Senão Define uma estrutura condicional que, dada a sua avaliação (V ou F), determina qual caminho do algoritmo será executado. Permite a escolha de um grupo de ações (bloco) a ser executado quando determinadas condições, representadas por expressões lógicas e/ou relacionais, são satisfeitas ou não. Os tipo de seleção apresentados serão: Simples, Composta e Encadeada. Exemplo - Seleção Simples: Classifique um valor qualquer fornecido X, se é maior que zero. Quando precisamos testar uma certa condição antes de executar uma ação. X &lt;- 7 if(X &gt; 0) { # Início do bloco Verdadeiro print(&quot;Valor maior que zero&quot;) } # Final do bloco Verdadeiro ## [1] &quot;Valor maior que zero&quot; OBS: Quando houver somente uma ação primitiva, a estrutura pode ser: X &lt;- 7 if(X &gt; 0) print(&quot;Valor maior que zero&quot;) ## [1] &quot;Valor maior que zero&quot; Exemplo - Seleção Composta: Classifique um valor qualquer fornecido X, se é maior que zero, ou menor ou igual a zero. Utilizadas em situações em que duas alternativas dependem de uma mesma condição: uma da condição VERDADEIRA, e outra da condição FALSA. X &lt;- -0.8987 if(X &gt; 0){ print(&quot;Valor maior que zero&quot;) }else{ # Início do bloco Falso print(&quot;Valor menor ou igual a zero&quot;) } # Fim do bloco Falso ## [1] &quot;Valor menor ou igual a zero&quot; Exemplo - Seleção Encadeada: Classifique um valor qualquer fornecido X, se é maior que zero, menor do que zero ou igual a zero. É o agrupamento de várias seleções, ocorre quanto uma determinada ação, ou bloco deve ser executado se um grande conjunto de possibilidades ou combinações de situações for satisfeito. X &lt;- 0.1 if(X &gt; 0){ print(&quot;Valor maior que zero&quot;) }else{ if(X&lt; 0 ){ print(&quot;Valor menor que zero&quot;) }else{ print(&quot;Valor igual a zero&quot;) } } ## [1] &quot;Valor maior que zero&quot; Observe que as etruturas acima apresentadas são funcionais para classificação de um único valor. Contudo para a classificação de vários valores em um vetor, recomenda-e o uso da função if_else do pacote dplyr disponível no tidyverse. library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 -- ## v ggplot2 3.3.3 v purrr 0.3.4 ## v tibble 3.0.5 v dplyr 1.0.3 ## v tidyr 1.1.2 v stringr 1.4.0 ## v readr 1.4.0 v forcats 0.5.0 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() ## x dplyr::select() masks MASS::select() numeros &lt;- c(-0.8, 1, 5, 0, -4) if_else(numeros&lt;0,&quot;Negativo&quot;,if_else(numeros==0,&quot;Nulo&quot;,&quot;Positivo&quot;)) ## [1] &quot;Negativo&quot; &quot;Positivo&quot; &quot;Positivo&quot; &quot;Nulo&quot; &quot;Negativo&quot; b) Selecione caso Muitas vezes nos deparamos com situações onde são necessários necessário duas ou mais operações condicionais para classificação. Nessa situações poderemos utilizar a estrutura Selecione caso, que no R pode ser acessada com a função case_when (do pacote dplyr). Essa função é útil para vetorizar instruções condicionais. Isso é semelhante a if_else mas pode gerar qualquer número de valores, em vez de apenas TRUE ou FALSE. Aqui está um exemplo que retorna o dia da semana em função do número de 1 a 7, onde qualquer valor fora desse intervalo é classificado como número inválido. dia &lt;- c(1,2,3,4,5,6,7,0,8) case_when( dia == 1 ~ &quot;Domingo&quot;, dia == 2 ~ &quot;Segunda-feira&quot;, dia == 3 ~ &quot;Terça-feira&quot;, dia == 4 ~ &quot;Quarta-feira&quot;, dia == 5 ~ &quot;Quinta-feira&quot;, dia == 6 ~ &quot;Sexta-feira&quot;, dia == 7 ~ &quot;Sábado&quot;, TRUE ~ &quot;número inválido&quot; ) ## [1] &quot;Domingo&quot; &quot;Segunda-feira&quot; &quot;Terça-feira&quot; &quot;Quarta-feira&quot; ## [5] &quot;Quinta-feira&quot; &quot;Sexta-feira&quot; &quot;Sábado&quot; &quot;número inválido&quot; ## [9] &quot;número inválido&quot; 6.1.3 Repetição Enquanto, Faça-Enquanto ou Para Define uma estrutura de iteração condicional (V ou F) ou contada (pré-definida) de instruções. É uma estrutura da controle do fluxo de execução que permite repetir diversas vezes um mesmo trecho do algoritmo, porém, sempre verificando ANTES de cada execução se é permitido executar o mesmo trecho. a) Repetição com teste no Início O Enquanto (while) permite que um determinado comando (ou bloco) seja repetido enquanto uma determinada for VERDADEIRA. Muitas vezes precisamos estabelecer um modo de contagem (contador), ou seja, uma variável (\\(i\\) por exemplo) com um dado valor inicial que é incrementado a cada repetição. Quando o resultado da for FALSO o comando de repetição é abandonado. Se na primeira vez o resultado for FALSO, os comandos NÃO SÃO EXECUTADOS. Exemplo: Imprima os números menores ou iguais a 10. i=1 while(i&lt;=10){ print(i) i=i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 b) Repetição com teste no Final Uma das estruturas com teste no final é a RepitaSe (repeat...if), que permite que um comando, ou bloco de comandos sejam executados enquanto uma determinada seja FALSA. Verificamos que, devido a sua sintaxe os comandos dentro do bloco São Executados Pelo Menos Uma Vez, independentemente da validade da condição. Isso ocorre pois a inspeção da ocorre no FINAL da estrutura. Quando o resultado da for VERDADEIRO o comando de repetição é abandonado. Entretanto, os comandos SÃO EXECUTADOS PELO MENOS UMA VEZ. Exemplo: Imprima os números menores ou iguais a 10. i=1 repeat{ print(i) i=i+1 if(i&gt;10) break } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 c) Repetição com Variável de Controle As estruturas while e repeat...if ocorrem em casos de difícil determinação do número de vezes que um comando, ou bloco, será executado. A Estrutura Para (for) é diferente, já que sempre repete a execução do bloco um número pré-determinado de vezes, pois ela não prevê uma condição e possui limites fixos. Exemplo: Imprima os números menores ou iguais a 10. for(i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Exemplo: Elabore um algoritmo que, utilizando uma das estruturas de repetição imprima a tabuada do número 5. for(i in 1:10){ print(paste(&quot;5 x&quot;,i,&quot;=&quot;,i*5)) } ## [1] &quot;5 x 1 = 5&quot; ## [1] &quot;5 x 2 = 10&quot; ## [1] &quot;5 x 3 = 15&quot; ## [1] &quot;5 x 4 = 20&quot; ## [1] &quot;5 x 5 = 25&quot; ## [1] &quot;5 x 6 = 30&quot; ## [1] &quot;5 x 7 = 35&quot; ## [1] &quot;5 x 8 = 40&quot; ## [1] &quot;5 x 9 = 45&quot; ## [1] &quot;5 x 10 = 50&quot; 6.2 Exercícios 1) Crie uma script/função que peça dois números e imprima o maior deles. 2) Crie um script/função que peça um número e informe se o número é inteiro ou decimal. 3) Crie um script/função que leia um número de 1 a 7 e exiba o dia correspondente da semana. (1- Domingo, 2- Segunda, , 7-Sábado.). Caso o usuário digitar um número diferente o programa deve escrever Valor invalido. 4) Crie um script/função que verifique se uma letra digitada é vogal ou consoante. 5) Crie um script/função que leia três números e mostre o maior e o menor deles. 6) Elabore um algoritmo que, classifique um número \\(X\\), fornecido pelo usuário, em par ou ímpar, utilize o operador % para o cálculo do resto da divisão. 7) Construa um algoritmo sequencial que calcule as raízes de uma equação do 2º grau (\\(ax^2 + bx + c\\)), sendo os valores de \\(a\\), \\(b\\) e \\(c\\) devem ser fornecidos pelo usuário. Considere: \\[ \\Delta = b^2-4 a c \\] se \\(\\Delta &gt; 0\\) \\[ x_1 = \\frac{-b+\\sqrt{\\Delta} }{2a} \\\\ x_2 = \\frac{-b-\\sqrt{\\Delta} }{2a} \\] se \\(\\Delta = 0\\) \\[ x= \\frac{-b}{2a} \\] se \\(\\Delta &lt; 0\\) As raízes são imaginárias 8) Faça um programa que imprima uma frase \\(n\\) vezes na tela do computador, \\(n\\) deve ser um número fornecido pelo usuário. 9) Faça um programa que imprima na tela os números de 1 a 20. 10) Faça um programa para obter as sequências de 0 a 25 com passo igual a 2. 11) Escreva um programa no qual o usuário digite dois números e o programa deve apresentar todos os números inteiros entre esses dois números. Se os números forem iguais, o programa deve exibir uma mensagem dizendo para o usuário digitar dois números inteiros diferentes. 12) Elabore um algoritmo que calcule e escreva o valor S, em que: \\[ S = 1 - \\frac{2}{4} + \\frac{3}{9} - \\frac{4}{16} + \\cdots - \\frac{10}{100} = 0,6456349 \\] 13) Construa um algoritmo que verifique se o número fornecido pelo usuário (inteiro maior que 1) é primo ou não (números primos são os números naturais que têm apenas dois divisores o 1 e ele mesmo, exemplo (2, 3, 5, 7, 11, 13, 17). "],["estrutura-de-dados.html", "7 Estrutura de dados 7.1 Atomic vector 7.2 Factor 7.3 Matrizes e Arrays 7.4 Listas 7.5 Data frames", " 7 Estrutura de dados A declaração de variáveis, uma a uma, é suficiente para a codificação algorítmica da solução de uma ampla gama de problemas até agora estudados. Entretanto, esse tipo de declaração é insuficiente para resolver um grande número de problemas computacionais. A quantidade de tipos de dados primitivos (caractere, real, inteiro, lógico) não é suficiente para representar toda e qualquer informação que possa surgir. Assim, em muitas situações, esses recursos de representação são escassos, o que poderá ser suprimido se existisse mais tipos de dados ou, ainda melhor, se esses tipos pudessem ser construídos, à medida que fossem necessários. Construiremos novos tipos de dados a partir da composição de tipos primitivos. Esses novos tipos tem o formato denominado estrutura de dados que define como os tipos primitivos são organizados. Tipos básicos de estrutura no R: Atomic vector: homogêneo e unidimensional Factor: homogêmeo e unidimensional Matriz: homogêneo e bidimensional Array: homogêneo e multidimensional Lista: heterogêneo Data frame: heterogêneo 7.1 Atomic vector Atomic vectors são a estrutura de objetos mais simples do R, caracterizados por não terem dimensão. Podem ser vistos como uma caixa com um rótulo ou nome colado a ela, que num dado instante guarda um determinado objeto, essa caixa pode ter seu conteúdo alterado diversas vezes. Tipos de atomic vectos: lógico integer double complexo character Figure 7.1: O objeto identificado como X possui um tipo numérico inteiro cujo valor é 5. (meu_inteiro &lt;- 5) ## [1] 5 (meu_double &lt;- 8.50) ## [1] 8.5 (meu_logico &lt;- TRUE) ## [1] TRUE (meu_char &lt;- &quot;A&quot;) ## [1] &quot;A&quot; De forma análoga, no conceito de estrutura de dados uma caixa poderá comportar não apenas uma e somente uma informação, a caixa comportará um conjunto de dados, desde que previamente organizada, ou seja, dividida em compartimentos. A função c(), o c é de concatenate utilizada para criação de um atomic vector com mais de um valor. Figure 7.2: O objeto identificado como X possui um tipo numérico inteiro cujos valores são 5, 8, 0, 2, 1 e 9. X &lt;- c(5,8,0,2,1,9) Y &lt;- c(0.5, 0.8, 1.5, 6.8) L &lt;- c(TRUE, FALSE, T, F) M &lt;- c(&quot;A&quot;, &quot;mais&quot;, &quot;bonita&quot;) As funções class e mode auxiliam na determinação do tipo de objeto. class(X) ## [1] &quot;numeric&quot; mode(X) ## [1] &quot;numeric&quot; class(M) ## [1] &quot;character&quot; mode(M) ## [1] &quot;character&quot; Observação: Coerção ocorre quando dois tipos de objetos são inseridos uma estrutura homogênea (atomic vectors, arrays ou matrizes), o R converterá o objeto para o tipo mais flexível, na ordem: 1-Lógico 2-Inteiro 3-Double 4-Caracter c(T,3,5.5,&quot;bela&quot;) ## [1] &quot;TRUE&quot; &quot;3&quot; &quot;5.5&quot; &quot;bela&quot; c(T,3,5.5) ## [1] 1.0 3.0 5.5 7.2 Factor Factors são utilizados para armazernar dados categorizados e são caracterizados por conterem apenas valores pré-definidos, chamados levels; e se basearem num vetor de inteiros. Dentro do objeto, os levels são organizados em ordem alfabética. # Função factor trat&lt;-factor(c(&quot;T1&quot;,&quot;T1&quot;,&quot;T1&quot;,&quot;T2&quot;,&quot;T2&quot;,&quot;T2&quot;,&quot;T3&quot;,&quot;T3&quot;,&quot;T3&quot;)) trat ## [1] T1 T1 T1 T2 T2 T2 T3 T3 T3 ## Levels: T1 T2 T3 # Função gf (Generate Factor) TRAT &lt;- gl(3,3, labels = c(&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;) ) TRAT ## [1] T1 T1 T1 T2 T2 T2 T3 T3 T3 ## Levels: T1 T2 T3 # Extraindo o níveis de um fator levels(trat) ## [1] &quot;T1&quot; &quot;T2&quot; &quot;T3&quot; 7.3 Matrizes e Arrays Matrizes e arrays são definidos usando as funções matrix() e array(), respectivamente. São objetos multidimensionais. No caso da matriz, os compartimentos, podem estar arranjados, assim: Figure 7.3: O objeto identificado como X possui um tipo numérico inteiro bidimensional organizado na forma matricial com 6 linhas e 6 colunas totalizando 36 elementos. No R dois argumentos são utilizados na função matrix() para determinar o número de colunas e forma com a qual será o preeenchimento dos elementos na matriz, por linha (byrow=FALSE, default) ou por coluna (byrow=TRUE). Compare as duas matriz do exemplo abaixo. Preenchimento da matriz por coluna. mat1 &lt;- matrix(1:36, ncol = 6, byrow = FALSE) mat1 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 7 13 19 25 31 ## [2,] 2 8 14 20 26 32 ## [3,] 3 9 15 21 27 33 ## [4,] 4 10 16 22 28 34 ## [5,] 5 11 17 23 29 35 ## [6,] 6 12 18 24 30 36 Preenchimento da matriz por linha mat2 &lt;- matrix(1:36, ncol = 6, byrow = TRUE) mat2 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 3 4 5 6 ## [2,] 7 8 9 10 11 12 ## [3,] 13 14 15 16 17 18 ## [4,] 19 20 21 22 23 24 ## [5,] 25 26 27 28 29 30 ## [6,] 31 32 33 34 35 36 Arrays são objetos que podem conter dois ou mais dados bidimensionais. Por exemplo, em matrizes quadradas podem conter duas linhas e duas colunas e a dimensão pode ter cinco. Os arrays podem armazenar os valores tendo apenas um tipo semelhante de tipos de dados. Os dados podem ser mais de uma dimensão, onde existem linhas e colunas e dimensões de algum comprimento. A função array() possui dois argumentos, data que receberá o vetor contendo os elementos e dim que receberá um vetor decrevendo o tamanho de cada dimensão. Vamos criar um array com duas matrizes de 4 linhas e 3 colunas meu_array &lt;- array(1:24, c(4,3,2)) meu_array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 Os nomes das linhas, colunas e matrizes do array podem ser nomeados a partir de uma lista definida no argumento dimnames da função array(), como apresentado abaixo: linhas &lt;- c(&quot;Lin1&quot;, &quot;Lin2&quot;, &quot;Lin3&quot;, &quot;Lin4&quot;) colunas &lt;- c(&quot;Col1&quot;,&quot;Col2&quot;,&quot;Col3&quot;) matrizes&lt;- c(&quot;Matriz1&quot;, &quot;Matriz2&quot;) meu_array &lt;- array(1:24, c(4,3,2), dimnames = list(linhas,colunas, matrizes) ) meu_array ## , , Matriz1 ## ## Col1 Col2 Col3 ## Lin1 1 5 9 ## Lin2 2 6 10 ## Lin3 3 7 11 ## Lin4 4 8 12 ## ## , , Matriz2 ## ## Col1 Col2 Col3 ## Lin1 13 17 21 ## Lin2 14 18 22 ## Lin3 15 19 23 ## Lin4 16 20 24 Para saber qual é o tipo de um objeto, utilizamos a função typeof() e class. # Array typeof(meu_array) ## [1] &quot;integer&quot; class(meu_array) ## [1] &quot;array&quot; # Matriz typeof(mat1) ## [1] &quot;integer&quot; class(mat1) ## [1] &quot;matrix&quot; &quot;array&quot; # Fator typeof(trat) ## [1] &quot;integer&quot; class(trat) ## [1] &quot;factor&quot; # Atomic vector typeof(Y) ## [1] &quot;double&quot; class(Y) ## [1] &quot;numeric&quot; As funções length(), dim(), nrow(), ncol() são usadas para determinar o comprimento de cada dimensão de um objeto. Observe que atomic vector e factor são estruturas unidimensionais, assim, somente a função length() retornará o número de elementos do objeto, e as demais função retornarão valor nulo NULL. # Array length(meu_array) ## [1] 24 dim(meu_array) ## [1] 4 3 2 nrow(meu_array) ## [1] 4 ncol(meu_array) ## [1] 3 # Matriz length(mat1) ## [1] 36 dim(mat1) ## [1] 6 6 nrow(mat1) ## [1] 6 ncol(mat1) ## [1] 6 # Fator length(trat) ## [1] 9 dim(trat) ## NULL nrow(trat) ## NULL ncol(trat) ## NULL # Atomic vector length(Y) ## [1] 4 dim(Y) ## NULL nrow(Y) ## NULL ncol(Y) ## NULL Todos os objetos apresentados até agora (atomic vector, factor, matrix e arrays) podem ser classificados como estruturas de dados HOMOGÊNEA, pois são compostas por variáveis do mesmo tipo primitivo (inteiro, double, lógico ou caracter). Figure 7.4: Estrutura de dados Homogênea é uma coleção de variáveis de mesmo tipo, acessíveis com um único nome e armazenados contiguamente (um após o outro) na memória. Se um conjunto homogêneo de dados é composto por variáveis do mesmo tipo, um conjunto HETEROGÊNEO de dados é composto por elementos que não são do mesmo tipo primitivo. No R temos as listas e os data.frames. Figure 7.5: As estruturas heterogêneas constituem um recurso importante para a organização dos dados utilizados devido à possibilidade de tratar um grupo de valores como uma única variável, similar às estruturas homogêneas. 7.4 Listas São estrutras de dados heterogêneas, ou seja, podem ser formadas por vetores de diferentes tipos de dados e de diferentes comprimentos. Em R são frequentemente utilizadas para a passagem de vários argumentos de controle dentro de uma função. Começaremos criando uma lista que consiste em três partes: 4 informações de caracteres em um vetor denominado a, 8 informações numéricas em um vetor denominado b e 3 informações lógicas em um vetor denominado c: a&lt;-c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;) b&lt;-c(1,2,3,4,4,3,2,1) c&lt;-c(T,T,F) Agora vamos utilizar a função list() para agrupar esses objetos. minha_lista &lt;- list(a,b,c) minha_lista ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ## ## [[2]] ## [1] 1 2 3 4 4 3 2 1 ## ## [[3]] ## [1] TRUE TRUE FALSE Observe que as funções typeof() e class retornam list e a função length retorna o número de atomic vectors utilizados na criação da lista. Funções como dim(), nrow() e ncol() retornarão NULL. typeof(minha_lista) ## [1] &quot;list&quot; class(minha_lista) ## [1] &quot;list&quot; length(minha_lista) ## [1] 3 Para conseguirmos o número de elementos em cada objeto dentro da lista, poderemos utlizar a função lapply() junto com a função length(). lapply(minha_lista,length) ## [[1]] ## [1] 4 ## ## [[2]] ## [1] 8 ## ## [[3]] ## [1] 3 A função lapply pode ser utilizada juntamente com typeof e/ou class. lapply(minha_lista,typeof) ## [[1]] ## [1] &quot;character&quot; ## ## [[2]] ## [1] &quot;double&quot; ## ## [[3]] ## [1] &quot;logical&quot; 7.5 Data frames Semelhantes às listas, os data.frames São estrutras de dados heterogêneas, que podem ser formadas por vetores de diferentes tipos de dados, contudo, todos os vetores têm o mesmo comprimento. São definidos usando a função data.frame(). Um data.frame é um objeto com linhas e colunas (parecido com a matriz). As linhas de um data.frame contêm diferentes observações do estudo em questão, denominadas registros. As colunas, por sua vez, contêm os valores de diferentes variáveis. Os valores no corpo de uma matriz podem ser apenas números; aqueles em um data.frame também podem ser números, mas também podem ser texto (por exemplo, os nomes dos níveis de fator para variáveis categóricas, como masculino ou feminino em uma variável chamada gênero), eles podem ser datas do calendário (por exemplo, 05/01/21) , ou podem ser variáveis lógicas (TRUE ou FALSE). A etapa mais importante do Data Science é obter o data.frame absolutamente correto. A expectativa é que você tenha usado uma planilha como o Excel para inserir e editar os dados e o que requer alguma prática é aprender exatamente como colocar seus números na planilha. Existem inúmeras maneiras de fazer errado, mas apenas uma maneira de fazer certo. E esta não é a maneira que a maioria das pessoas acha intuitivamente a mais óbvia. O principal é o seguinte: todos os valores da mesma variável devem estar na mesma coluna. Se você fez um experimento com três tratamentos (controle, pré-aquecido e pré-resfriado) e quatro medições por tratamento, pode parecer uma boa ideia criar a planilha como esta: controle pré-aquecido pré-resfriado 6.1 6.3 7.1 5.9 6.2 8.2 5.8 5.8 7.3 5.4 6.3 6.9 No entanto, este não é um data.frame, pois os valores da variável resposta aparecem em três colunas diferentes, em vez de todos na mesma coluna. A forma correta de inserir esses dados é ter duas colunas: uma para a variável resposta e outra para os níveis do fator experimental denominado Tratamento (controle, pré-aquecido e pré-resfriado). Aqui estão os mesmos dados, inseridos corretamente como um data.frame: Resposta Tratamento 6.1 controle 5.9 controle 5.8 controle 5.4 controle 6.3 pré-aquecido 6.2 pré-aquecido 5.8 pré-aquecido 6.3 pré-aquecido 7.1 pré-resfriado 8.2 pré-resfriado 7.3 pré-resfriado 6.9 pré-resfriado Vamos criar esse data.frame, primeiramente, criaremos os distintos vetores, numérico e fator. Resposta &lt;- c(6.1,5.9,5.8,5.4,6.3,6.2,5.8,6.3,7.1,8.2,7.3,6.9) Tratamento &lt;- gl(3,4,labels = c(&quot;controle&quot;,&quot;pré-aquecido&quot;,&quot;pré-resfriado&quot;) ) Agrora vamos agrupar esses vetores em um data.frame. dados &lt;- data.frame(Resposta, Tratamento) dados ## Resposta Tratamento ## 1 6.1 controle ## 2 5.9 controle ## 3 5.8 controle ## 4 5.4 controle ## 5 6.3 pré-aquecido ## 6 6.2 pré-aquecido ## 7 5.8 pré-aquecido ## 8 6.3 pré-aquecido ## 9 7.1 pré-resfriado ## 10 8.2 pré-resfriado ## 11 7.3 pré-resfriado ## 12 6.9 pré-resfriado Agora, vamos extrair as informações a respeito desse data.frame: Utilize a função length() para retornar o número de vetores (colunas) utilizados para criação do data.frame. length(dados) ## [1] 2 A função dim() retornará o número de linhas e o número de colunas do objeto, em analogia, poder-se-ia utilizar as funções nrow() e ncol(). dim(dados) ## [1] 12 2 nrow(dados) ## [1] 12 ncol(dados) ## [1] 2 As funções str() e glimpse() dos pacotes base e dplyr, respectivamente, fornecem um resumo rápido do data.frame: str(dados) ## &#39;data.frame&#39;: 12 obs. of 2 variables: ## $ Resposta : num 6.1 5.9 5.8 5.4 6.3 6.2 5.8 6.3 7.1 8.2 ... ## $ Tratamento: Factor w/ 3 levels &quot;controle&quot;,&quot;pré-aquecido&quot;,..: 1 1 1 1 2 2 2 2 3 3 ... Observe que vamos chamar a função glimpse utilizado o :: definindo anteriormente o nome do pacote dplyr na qual ela se encontra, sem a necessidade prévia de carregarmos esse pacote no ambiente de trabalho do R. dplyr::glimpse(dados) ## Rows: 12 ## Columns: 2 ## $ Resposta &lt;dbl&gt; 6.1, 5.9, 5.8, 5.4, 6.3, 6.2, 5.8, 6.3, 7.1, 8.2, 7.3, 6.9 ## $ Tratamento &lt;fct&gt; controle, controle, controle, controle, pré-aquecido, pr... A função names() retorna o nome das colunas (vetores) de um data.frame. names(dados) ## [1] &quot;Resposta&quot; &quot;Tratamento&quot; A função names() também pode ser utilizada para atribuir/modificar os nomes das colunas do data.frame. names(dados) &lt;- c(&quot;Altura_cm&quot;, &quot;Método&quot;) dados ## Altura_cm Método ## 1 6.1 controle ## 2 5.9 controle ## 3 5.8 controle ## 4 5.4 controle ## 5 6.3 pré-aquecido ## 6 6.2 pré-aquecido ## 7 5.8 pré-aquecido ## 8 6.3 pré-aquecido ## 9 7.1 pré-resfriado ## 10 8.2 pré-resfriado ## 11 7.3 pré-resfriado ## 12 6.9 pré-resfriado O ponto principal sobre como trabalhar efetivamente com data.frames é entendermos o uso de subscritos (ou indexação). No R, os subscritos aparecem entre colchetes [ , ]. Lembre-se que um dataframe é um objeto bidimensional, compreendendo linhas e colunas. As linhas são referenciadas pelo primeiro subscrito (à esquerda da vírgula) , as colunas pelo segundo subscrito (à direita da vírgula). Portanto, para extrairmos a segunda observação da variável resposta Altura_cm usamos. Observe que o retorno é um atomic vector (vetor). dados[2,1] ## [1] 5.9 Para extrairmos um subconjuto desse data.frame, composto somente pelos valores de altura referentes ao tratamento (método) pré-aquecido (linhas 5 a 8), vamos utilizar os :, deixando o índice das colunas em branco na indexação. Observe que o retorno é um data.frame. dados[5:8,] ## Altura_cm Método ## 5 6.3 pré-aquecido ## 6 6.2 pré-aquecido ## 7 5.8 pré-aquecido ## 8 6.3 pré-aquecido Se o objetivo for apenas os valores, temos. dados[5:8,1] ## [1] 6.3 6.2 5.8 6.3 Observe que o retorno é um vetor. Poderíamos extrair todos os valores a partir do operador de acesso $, chamando primeiramente o objeto e em seguida o nome da coluna. O retorno é um vetor. dados$Altura_cm ## [1] 6.1 5.9 5.8 5.4 6.3 6.2 5.8 6.3 7.1 8.2 7.3 6.9 Observe a diferença no retorno das diferentes formas de acesso a uma coluna. No caso abaixo, vamos acessar a coluna Altura_cm, cujo retorno será um vetor, semelhante ao exemplo anterior. dados[,1] ## [1] 6.1 5.9 5.8 5.4 6.3 6.2 5.8 6.3 7.1 8.2 7.3 6.9 Compare com extração abaixo, nesse caso, temos como retorno um data.frame. dados[1] ## Altura_cm ## 1 6.1 ## 2 5.9 ## 3 5.8 ## 4 5.4 ## 5 6.3 ## 6 6.2 ## 7 5.8 ## 8 6.3 ## 9 7.1 ## 10 8.2 ## 11 7.3 ## 12 6.9 Transformações nos dados podem ser realizadas utilizando esse operador, por exemplo, vamos criar uma nova variável (coluna) denominada Altura_m a partir da Altura_cm, dividindo cada valor por 100. dados$Altura_m &lt;- dados$Altura_cm / 100 dados ## Altura_cm Método Altura_m ## 1 6.1 controle 0.061 ## 2 5.9 controle 0.059 ## 3 5.8 controle 0.058 ## 4 5.4 controle 0.054 ## 5 6.3 pré-aquecido 0.063 ## 6 6.2 pré-aquecido 0.062 ## 7 5.8 pré-aquecido 0.058 ## 8 6.3 pré-aquecido 0.063 ## 9 7.1 pré-resfriado 0.071 ## 10 8.2 pré-resfriado 0.082 ## 11 7.3 pré-resfriado 0.073 ## 12 6.9 pré-resfriado 0.069 Vamos criar a coluna Bloco (variável) para identificação dos blocos do experimento. dados$Bloco &lt;- gl(4,1,12,labels = c(&quot;I&quot;,&quot;II&quot;,&quot;III&quot;,&quot;IV&quot;)) dados ## Altura_cm Método Altura_m Bloco ## 1 6.1 controle 0.061 I ## 2 5.9 controle 0.059 II ## 3 5.8 controle 0.058 III ## 4 5.4 controle 0.054 IV ## 5 6.3 pré-aquecido 0.063 I ## 6 6.2 pré-aquecido 0.062 II ## 7 5.8 pré-aquecido 0.058 III ## 8 6.3 pré-aquecido 0.063 IV ## 9 7.1 pré-resfriado 0.071 I ## 10 8.2 pré-resfriado 0.082 II ## 11 7.3 pré-resfriado 0.073 III ## 12 6.9 pré-resfriado 0.069 IV Agora podemos modificar a posição das colunas. Observe que vamos reciclar o objeto dados, ou seja, vamos guardar esse novo data.frame no mesmo identificador. dados &lt;- dados[,c(2,4,1,3)] dados ## Método Bloco Altura_cm Altura_m ## 1 controle I 6.1 0.061 ## 2 controle II 5.9 0.059 ## 3 controle III 5.8 0.058 ## 4 controle IV 5.4 0.054 ## 5 pré-aquecido I 6.3 0.063 ## 6 pré-aquecido II 6.2 0.062 ## 7 pré-aquecido III 5.8 0.058 ## 8 pré-aquecido IV 6.3 0.063 ## 9 pré-resfriado I 7.1 0.071 ## 10 pré-resfriado II 8.2 0.082 ## 11 pré-resfriado III 7.3 0.073 ## 12 pré-resfriado IV 6.9 0.069 Vamor criar o vetor identificação (\\(ID\\)) para cada observação. dados$ID &lt;- paste(&quot;obs&quot;, 1:nrow(dados), sep=&quot;_&quot; ) dados ## Método Bloco Altura_cm Altura_m ID ## 1 controle I 6.1 0.061 obs_1 ## 2 controle II 5.9 0.059 obs_2 ## 3 controle III 5.8 0.058 obs_3 ## 4 controle IV 5.4 0.054 obs_4 ## 5 pré-aquecido I 6.3 0.063 obs_5 ## 6 pré-aquecido II 6.2 0.062 obs_6 ## 7 pré-aquecido III 5.8 0.058 obs_7 ## 8 pré-aquecido IV 6.3 0.063 obs_8 ## 9 pré-resfriado I 7.1 0.071 obs_9 ## 10 pré-resfriado II 8.2 0.082 obs_10 ## 11 pré-resfriado III 7.3 0.073 obs_11 ## 12 pré-resfriado IV 6.9 0.069 obs_12 Agora vamos reordenar o data.frame por Altura_cm da menor para a maior (utilize a função order()), em seguida, da maior para a menor nota (argumento decreasing = T). # Classificação do menor para o maior dados[order(dados$Altura_cm),] ## Método Bloco Altura_cm Altura_m ID ## 4 controle IV 5.4 0.054 obs_4 ## 3 controle III 5.8 0.058 obs_3 ## 7 pré-aquecido III 5.8 0.058 obs_7 ## 2 controle II 5.9 0.059 obs_2 ## 1 controle I 6.1 0.061 obs_1 ## 6 pré-aquecido II 6.2 0.062 obs_6 ## 5 pré-aquecido I 6.3 0.063 obs_5 ## 8 pré-aquecido IV 6.3 0.063 obs_8 ## 12 pré-resfriado IV 6.9 0.069 obs_12 ## 9 pré-resfriado I 7.1 0.071 obs_9 ## 11 pré-resfriado III 7.3 0.073 obs_11 ## 10 pré-resfriado II 8.2 0.082 obs_10 # Classificação do maior para o menor dados[order(dados$Altura_cm,decreasing=TRUE),] ## Método Bloco Altura_cm Altura_m ID ## 10 pré-resfriado II 8.2 0.082 obs_10 ## 11 pré-resfriado III 7.3 0.073 obs_11 ## 9 pré-resfriado I 7.1 0.071 obs_9 ## 12 pré-resfriado IV 6.9 0.069 obs_12 ## 5 pré-aquecido I 6.3 0.063 obs_5 ## 8 pré-aquecido IV 6.3 0.063 obs_8 ## 6 pré-aquecido II 6.2 0.062 obs_6 ## 1 controle I 6.1 0.061 obs_1 ## 2 controle II 5.9 0.059 obs_2 ## 3 controle III 5.8 0.058 obs_3 ## 7 pré-aquecido III 5.8 0.058 obs_7 ## 4 controle IV 5.4 0.054 obs_4 "],["visualização-de-dados-com-o-ggplot2.html", "8 Visualização de dados com o ggplot2 8.1 Criando um gráfico 8.2 Definindo temas 8.3 Controle de elementos do tema 8.4 Mapeando estéticos 8.5 Facetas 8.6 Objetos geométricos", " 8 Visualização de dados com o ggplot2 O R possui vários sistemas para fazer gráficos, mas o pacote ggplot2 é um dos mais elegantes e versáteis para realizar essa tarefa. o ggplot2 implementa a gramática dos gráficos, um sistema coerente para descrever e construir gráficos. Vamos carregar o tidyverse, que tem o pacote ggplot2 como um de seus elementos centrais. library(tidyverse) Importação dos dados Vamos realizar a importação, via web, do banco de dados geomorfologia.txt. URL &lt;- &quot;https://raw.githubusercontent.com/arpanosso/r_data_science_fcav/master/dados/geomorfologia.txt&quot; geomorfologia&lt;-read.table(URL, header = TRUE) glimpse(geomorfologia) ## Rows: 106 ## Columns: 22 ## $ SUP &lt;chr&gt; &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;,... ## $ Solo &lt;chr&gt; &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;, &quot;LV&quot;,... ## $ Amostra &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, ... ## $ X &lt;int&gt; 0, 25, 50, 75, 100, 125, 150, 175, 200, 225, 250, 275, 300,... ## $ AMG &lt;dbl&gt; 0.2, 0.1, 0.7, 0.4, 0.4, 0.4, 1.2, 0.8, 1.1, 1.2, 0.1, 0.2,... ## $ AG &lt;dbl&gt; 3.72, 4.27, 5.00, 3.80, 3.10, 3.80, 3.60, 4.70, 4.50, 5.90,... ## $ AM &lt;dbl&gt; 20.4, 22.6, 22.7, 23.7, 22.3, 23.8, 23.1, 25.8, 25.5, 32.8,... ## $ AF &lt;dbl&gt; 22.9, 23.6, 22.2, 24.4, 24.6, 19.1, 21.7, 21.1, 18.9, 19.8,... ## $ AMF &lt;dbl&gt; 30.0, 28.4, 26.9, 26.7, 26.9, 27.1, 26.5, 24.7, 25.4, 21.7,... ## $ SILTE &lt;dbl&gt; 1.2, 1.2, 1.2, 0.6, 2.1, 2.2, 0.7, 0.2, 2.5, 0.2, 2.5, 2.6,... ## $ ARGILA &lt;dbl&gt; 21.5, 20.4, 21.4, 20.5, 20.7, 23.5, 23.1, 22.7, 22.0, 18.5,... ## $ S_A &lt;dbl&gt; 0.05, 0.05, 0.05, 0.02, 0.10, 0.09, 0.03, 0.01, 0.11, 0.01,... ## $ AF_AG &lt;dbl&gt; 6.16, 5.53, 4.44, 6.42, 7.94, 5.03, 6.03, 4.49, 4.20, 3.36,... ## $ P &lt;dbl&gt; 42, 22, 41, 27, 11, 12, 11, 16, 38, 25, 25, 6, 6, 7, 5, 4, ... ## $ pH &lt;dbl&gt; 4.2, 3.8, 4.8, 4.0, 4.4, 4.0, 4.8, 5.4, 4.4, 5.2, 4.5, 5.1,... ## $ K &lt;dbl&gt; 0.27, 0.11, 0.34, 0.13, 0.11, 0.14, 0.23, 0.28, 0.19, 0.14,... ## $ Ca &lt;dbl&gt; 1.4, 0.4, 2.4, 0.7, 1.4, 0.6, 1.6, 3.3, 1.6, 2.9, 1.3, 1.6,... ## $ Mg &lt;dbl&gt; 0.3, 0.1, 0.4, 0.1, 0.3, 0.1, 0.7, 1.3, 0.5, 1.7, 0.6, 0.8,... ## $ H_Al &lt;dbl&gt; 5.2, 5.8, 4.2, 5.2, 4.2, 5.2, 3.4, 2.5, 5.2, 3.1, 4.2, 2.5,... ## $ SB &lt;dbl&gt; 1.97, 0.61, 3.14, 0.93, 1.81, 0.84, 2.53, 4.88, 2.29, 4.74,... ## $ T &lt;dbl&gt; 7.17, 6.41, 7.34, 6.13, 6.01, 6.04, 5.93, 7.38, 7.49, 7.84,... ## $ V &lt;dbl&gt; 27, 10, 43, 15, 30, 14, 43, 66, 31, 60, 32, 50, 22, 35, 36,... 8.1 Criando um gráfico Vamos criar um gráfico do teor de argila do solo ao longo do transecto estudado. Para isso utilizaremos dois operadores: 1) %&gt;% - chamado PIPE do pacote dplyr o qual pode ser construído com o atalho Ctrl + Shift + M. 2) + - adição, para o controle das camadas gráficas e parâmetros específicos. REGRA: o PIPE sempre opera DATA.FRAMES e tem como retorno DATA.FRAMES. Para o ggplot, o primeiro argumento SEMPRE será um data.frame. A forma mais simples para iniciarmos a confecção de nosso gráfico é construírmos cada etapa individual do gráfico, estudando os códigos por etapas. No código abaixo, construiremos somente a tela de plotagem do gráfico. geomorfologia %&gt;% ggplot() Se a nossa inteção é visualizar as alterações dos teores de argila ao longo do transecto nas diferentes superfícies geomórficas, vamos utilizar a função de estética aes(), dentro da função ggplot(), para definir quais as colunas do objeto geomorfologia serão utilizadas para criação do gráfico. Observe que os eixos, agora são desenhados. geomorfologia %&gt;% ggplot(aes(x=X, y =ARGILA)) Agora a geometria de pontos deve ser indicada, ou seja, qual o tipo de gráfico vamos contruir. Nesse caso, vamos utilizar o operador de adição + para adicioar uma camada de pontos a esse gráfico. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() ## Controlando geometrias Outras geometrias poderiam ser utlizadas, ao invés de pontos, poderíamos pedir uma geometria de linha: geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line() Ou poderíamos mesclar as duas geometrias: geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line()+ geom_point() Agora, finalmente, podemos controlar alguma propriedades dentro de cada geometria. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(col=&quot;blue&quot;, # cor da linha lwd= 0.7, # espessura da linha lty=2)+ # tipo de linha geom_point(shape=21, # tipo do marcador 0-14 são ocas de 15-18 sólidas e de 21-24 possuem borda e preenchimento fill=&quot;green&quot;, # cor do preenchimento do marcador col=&quot;red&quot;, # cor da borda do marcador size=3) # tamanho do marcador OBS: A forma de um ponto (marcador) é atribuido ao argumento shape. Há algumas duplicadas aparentes por exemplo, 0, 15 e 22 são quadrados. A diferença vem da interação das estéticas color e fill. As formas ocas são de 0 a 14 e sua borda é determinada por color, as formas sólidas são de 15 a 18 e são preenchidas por color, já as formas de 21 a 24 têm uma borda definida por color e e são preenchidas por fill. Podemos agora controlar os títulos dos eixos, a partir da função labs(). geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(col=&quot;blue&quot;, lwd= 0.7, lty=1)+ geom_point(shape=21, fill=&quot;green&quot;, col=&quot;red&quot;, size=3) + labs(x=&quot;Eixo x (m)&quot;,y=&quot;Teor de argila do solo (%)&quot;,title = &quot;Gráfico de Linha + Pontos&quot;) 8.2 Definindo temas Podemos utilizar diferentes temas, para isso, vamos, inicialmente, guardar o nosso gráfico em um objeto denominado meu_plot. meu_plot&lt;- geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_line(col=&quot;blue&quot;, lwd= 0.7, lty=1)+ geom_point(shape=21, fill=&quot;green&quot;, col=&quot;red&quot;, size=3) + labs(x=&quot;Eixo x (m)&quot;,y=&quot;Teor de argila do solo (%)&quot;,title = &quot;Gráfico de Linha + Pontos&quot;) Agora podemos aplicar um tema pré-definido a esse objeto gráfico a partir da família de função theme_. Compare os diferentes temas diponíveis. meu_plot + theme_minimal() meu_plot + theme_bw() meu_plot + theme_dark() # ... 8.3 Controle de elementos do tema Vários elementos do tema podem ser controlados a partir de funções específicas associadas à função theme. As funções element_ especificam a exibição de como os componentes sem dados do gráfico são desenhados. *element_blank: não desenha nada e não atribui espaço; *element_rect: bordas e fundos; *element_line: linhas; *element_text: texto; *rel () é usado para especificar os tamanhos relativos ao objeto original; *margin () é usado para especificar as margens dos elementos. Por exemplo, vamos duplicar o tamanho de fonte (rel(2)) do título do gráfico já criado meu_plot. meu_plot + theme(plot.title = element_text(size=rel(2))) Vamos modificar o alinhamento do e a cor do título do gráfico já criado meu_plot. meu_plot &lt;- meu_plot + theme(plot.title = element_text(hjust = 0.5, color = &quot;red&quot;)) meu_plot Alterando a área de plotagem. meu_plot &lt;- meu_plot + theme(panel.background = element_rect(fill=&quot;lightblue&quot;, color = &quot;red&quot;, linetype = &quot;dashed&quot;)) meu_plot Agora vamos fazer várias modificações, adicionando linhas de plotagem principais e secundárias, mudar as cores do texto dos eixos para vermelho, e as cores dos títulos dos eixos para verde escuro e alterando a cor do retângulo de plotagem exterior para cinza. meu_plot &lt;- meu_plot + theme(panel.grid.major = element_line(color=&quot;gray&quot;, linetype = &quot;dashed&quot;), panel.grid.minor = element_line(color=&quot;gray&quot;, linetype = &quot;dashed&quot;), axis.text = element_text(colour = &quot;red&quot;), axis.title = element_text(colour = &quot;darkgreen&quot;,size=rel(1.2)), plot.background = element_rect(fill=&quot;gray&quot;)) meu_plot Maiores informações a respeito dos parâmetros de controle dos elementos dos gráficos podem ser encontrados em https://ggplot2.tidyverse.org/reference/theme.html. 8.4 Mapeando estéticos Vamos voltar ao gráfico de dispersão (scatter) do teor de argila do solo ao longo do transecto estudado. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() Podemos agora adicionar uma terceira variável a esse gráfico, como tipo de solo ou a superfície geomórfica, e mapeá-la a partir de um estético (aesthetic). Esse estético é uma propriedade visual dos objetos no gráfico. Estéticos incluem coisas como tamanho, forma ou cor dos pontos. Vamos mapear as cores dos pontos para cada superfície geomórfica (SUP). Para mapear a estética cor à variável SUP, devemos associar o nome da estética ao nome da variável dentro de aes(). O ggplot2 atribuirá automaticamente uma cor singular para cada valor singular da variável, um processo conhecido como escalar (scaling). Automaticamente será adicionado uma legenda que explica quais níveis correspondem a quais valores. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, col = SUP) ) + geom_point() No exemplo anterior mapeamos SUP à estética cor, mas poderíamos ter mapeado SUP à estética de tamanho (size) da mesma maneira. Neste caso, o tamanho exato de cada ponto revela a sua superfície. Não é recomendado mapearmos a uma variável por meio do tamanho. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, size = SUP) ) + geom_point() ## Warning: Using size for a discrete variable is not advised. Poderíamos ter mapeado SUP à estética alpha, que controla a transparência e à forma dos pontos controlada pelas estética shape. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, alpha = SUP, shape=SUP, col=SUP) ) + geom_point() ## Warning: Using alpha for a discrete variable is not advised. 8.5 Facetas As facetas são consideradas uma maneira prática de adicionar mais variáveis categóricas às representações gráficas. Para criar facetas use a função facet_wrap(), cujo primeiro argumento deve ser uma fórmula (definida com ~ e o nome da variável categórica subsequente) e o segundo argumento é o número de linhas do painel gráfico. Compare os painéis abaixo: geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + facet_wrap(~SUP, nrow=1) geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + facet_wrap(~SUP, nrow=3) Outra importante e útil ferramenta é a função facet_grid que permite a incorporação de mais de uma variável na representação, no nosso exemplo, vamos adicionar o tipo de solo Solo. A fórmula conterá dois nomes de variáveis categóricas sepradas pelo ~ geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + facet_grid(SUP ~ Solo) Agora podemos mesclar as visualisações, utilizando o mapeamento estético e as facetas. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=Solo) ) + geom_point() + facet_wrap(~SUP, nrow=1) ou, geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=SUP) ) + geom_point() + facet_wrap(~Solo, nrow=4) + labs(x=&quot;Eixo x (m)&quot;, y= &quot;Teor de argila (%)&quot;, color=&quot;Superfície&quot;) 8.6 Objetos geométricos 8.6.1 Gráfico de Colunas Um geom_ é o objeto geométrico que um gráfico usa para representar os dados. Gráficos de colunas, por exemplo, usam o geom_col(). O preenchimento e as cores das bordas das colunas são controlados peloas argumentos fill e color dentro da função geom_col(). Gráfico de coluas, linhas e pontos, plotam os valores brutos. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_col(color=&quot;black&quot;,fill=&quot;aquamarine4&quot;) Gráfico de colunas pode ser é representado pela rotação dos eixos do gráfico anterior a partir de coord_flip(). geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_col(color=&quot;black&quot;,fill=&quot;aquamarine4&quot;) + coord_flip() 8.6.2 Gráfico de Barras Diferente do grafico de colunas, o gráfico de barras possibilita a representação de dados categóricos, vamos supor que devemos contar o número de observações em cada superfície geomórfica. A função geom_bar() conta os pontos em cada categoria de SUPautomaticamente. geomorfologia %&gt;% ggplot( aes(x=SUP) ) + geom_bar(color=&quot;black&quot;, fill=&quot;lightblue&quot;) POdemos colorir um gráfico de barras utilizando a estética fill: geomorfologia %&gt;% ggplot( aes(x=SUP, fill=SUP)) + geom_bar(color=&quot;black&quot;) Se adicionarmos uma segunda variáveis categórica, como o tipo de solo Solo, as barras são automaticamente empilhadas, ondem cada retângulo colorido representa uma combinação de SUP e Solo. geomorfologia %&gt;% ggplot( aes(x=SUP,fill=Solo)) + geom_bar(color=&quot;black&quot;) O empilhamento é realizado automaticamente, caso não queiramos o gráfico empilhado, utilizamos um dos três valores identity, dodge ou fill associados ao argumento position dentro de geom_bar(). geomorfologia %&gt;% ggplot( aes(x=SUP, fill=Solo)) + geom_bar(position = &quot;fill&quot;, color=&quot;black&quot;) geomorfologia %&gt;% ggplot( aes(x=SUP, fill=Solo)) + geom_bar(position = &quot;identity&quot;, color=&quot;black&quot;) geomorfologia %&gt;% ggplot( aes(x=SUP, fill=Solo)) + geom_bar(position = &quot;dodge&quot;, color=&quot;black&quot;) 8.6.3 Smoothers Vamos ajustar uma linha suave ao dados de teor de argila ao longo do transecto X estudado a partir de geom_smooth(). geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + geom_smooth() Dentro de geom_smooth() podemos controlar o tipo da linha e a cor da linha a partir de linetype e color, respectivamente. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA) ) + geom_point() + geom_smooth(linetype=2, color=&quot;red&quot;) Agora vamos aplicar uma linha suave para cada uma das superfície geomórfica. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=SUP) ) + geom_point() + geom_smooth() Agora vamos aplicar uma linha suave para cada uma das superfície geomórfica, apresentadas em diferentes facetas. geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=SUP) ) + geom_point() + geom_smooth() + facet_wrap(~SUP, nrow=1) Para apresentarmos as facetas em diferentes escalas (diferentes valores de X e Y em cada faceta), utilize o argumento scales = \"free\" em facet_wrap(). geomorfologia %&gt;% ggplot( aes(x=X, y =ARGILA, color=SUP) ) + geom_point() + geom_smooth() + facet_wrap(~SUP, nrow=1, scales = &quot;free&quot;) 8.6.4 Boxplot Conhecido como gráfico dos 5 números representa um resumos dos valores mínimo, primeiro quartil, mediana, terceiro quartil e máximo. Podem ser construídos para uma variável contínua a partir da geometria geom_boxplot(). Observe que dentro da função ggplot() não é necessário especificar o y, somente é atribuído a x a variável contínua ARGILA. geomorfologia %&gt;% ggplot( aes(x=ARGILA) ) + geom_boxplot() O boxplot é uma caixa que vai do 25º percentil ao 75º percentil da distribuição, uma distância conhecida como a amplitude interquartil (IIQ). No meo da caixa há uma linha que exibe a mediana, isto é, 50º percentil, da distribuição. Essas três linhas lhe dão um sentido da dispersão da distribuição e se ela é ou não simétrica sobre a mediana ou enviesada para um lado. Pontos visuais que exibem observações que caem mais do que 1,5 vez o IIQ de cada limite da caixa. Esses pontos foram da curva são incomuns, entãosão plotados individuaalmente. Uma linha (ou bigode de gato, dai o nome Box and Whiskers) que se estende de cada lado da caixa e vai até o ponto mais distante da distribuição que não seja um outlier. Suas coordenadas podem ser transposta por coord_flip() geomorfologia %&gt;% ggplot( aes(x=ARGILA) ) + geom_boxplot() + coord_flip() Outra alternativa para exibir a distribuição de uma variável contínua, podemos desmembrar por uma variável categórica aqui no boxplot. geomorfologia %&gt;% ggplot( aes(x=ARGILA, fill=SUP) ) + geom_boxplot() + coord_flip() 8.6.5 Histograma O gráfico histograma é facilmente construído a partir da função geom_histogram(). Semelhante ao geom_boxplot() dentro da função ggplot() é atribuído a x a variável contínua ARGILA. geomorfologia %&gt;% ggplot(aes(x=ARGILA)) + geom_histogram() Observe que o histograma foi construído com a frequencia absoluta de cada classe, ou seja, o número de observações (contagem) dentro de cada classe de teor de argila construída automaticamentem pela função. Se ao invés da contagem, quiséssemos a densidade de frenquência, deveremos utilizar y=..density.. dentro de aes(). geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram() Podemos estabelecer a amplitude dos intervalos em um histograma com o argumento bidwidth, que pe medido nas unidades da variável x. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram(binwidth = 2) Ou você pode especificar o número de classes a partir do argumento bins, que por default é igual a 30. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram(bins = 15) Vamos alterar as cores das bordas e preeenchimento das colunas. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram(bins = 15, color=&quot;black&quot;,fill=&quot;white&quot;) Podemos associar a curva suave de densidade no hitograma, a partir da função geom_density() e controlarmos a trnasparência e seu preenchimento a partir dos argumentos alpha e fill. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density..)) + geom_histogram(bins = 15,color=&quot;black&quot;,fill=&quot;white&quot;)+ geom_density(alpha=.10, fill=&quot;red&quot;) Finalmente, podemos construir um histograma da variável ARGILA para cada superfície geomórfica. geomorfologia %&gt;% ggplot(aes(x=ARGILA, y=..density.., color=SUP, fill=SUP)) + geom_histogram(bins = 15, color=&quot;black&quot;,fill=&quot;white&quot;)+ geom_density(alpha=.2)+ facet_wrap(~SUP, scales=&quot;free&quot;)+ labs(x=&quot;Teor de argila do solo (%)&quot;, y = &quot;Densidade&quot;, fill=&quot;Superfície&quot;, color=&quot;Superfície&quot;) + theme_dark() "]]
